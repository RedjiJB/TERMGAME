mission:
  id: command-line-mastery-advanced
  title: Command-Line Argument Processing and Tools
  difficulty: advanced
  description: 'Master advanced command-line techniques including argument parsing,
    xargs,

    parallel execution, and building sophisticated command pipelines. Essential

    skills for automation and system administration.


    Learn to harness the full power of the Unix command line!

    '
  estimated_time: 50
  xp_reward: 550
  tags:
  - command-line
  - xargs
  - arguments
  - automation
  - advanced
  - navigation
environment:
  image: ubuntu:22.04
  setup:
  - apt-get update
  - apt-get install -y coreutils findutils parallel bc
steps:
- id: xargs-introduction
  description: '**Understanding xargs**


    `xargs` converts input into arguments for another command. It solves the

    problem of "how do I use output of one command as arguments to another?"


    **The problem it solves:**

    ```bash

    # This doesn''t work:

    find . -name "*.txt" | rm        # rm expects args, not stdin!


    # This works:

    find . -name "*.txt" | xargs rm  # xargs converts stdin to args

    ```


    **Basic usage:**

    ```bash

    echo "file1 file2 file3" | xargs touch    # Creates 3 files

    find . -name "*.log" | xargs gzip         # Compress all .log files

    ```


    **Task:** Practice xargs basics.


    ```bash

    mkdir -p ~/cmdline

    cd ~/cmdline


    # Create test files

    mkdir testfiles

    echo "apple banana cherry" | xargs -n1 -I {} touch testfiles/{}.txt


    # Document xargs usage

    echo "xargs Introduction" > xargs_demo.txt

    echo "==================" >> xargs_demo.txt

    echo "" >> xargs_demo.txt


    echo "Files created:" >> xargs_demo.txt

    ls testfiles/ >> xargs_demo.txt


    echo "" >> xargs_demo.txt

    echo "Using xargs to process files:" >> xargs_demo.txt

    find testfiles -name "*.txt" | xargs -I {} echo "Found: {}" >> xargs_demo.txt


    cat xargs_demo.txt

    ```

    '
  hint: 'xargs takes input from stdin and converts it to command-line arguments.

    Use -I {} to specify a placeholder for the input in the command.

    '
  validation:
    type: file-exists
    path: ~/cmdline/xargs_demo.txt
    matcher: exists
  title: '**Understanding xargs**'
- id: xargs-options
  description: "**Advanced xargs Options**\n\n**Controlling execution:**\n```bash\n\
    xargs -n N        # Pass N arguments at a time\nxargs -L N        # Pass N lines\
    \ at a time\nxargs -I {}       # Replace-string (placeholder)\nxargs -P N    \
    \    # Run N processes in parallel\nxargs -t          # Print command before executing\
    \ (verbose)\nxargs -p          # Prompt before executing (interactive)\n```\n\n\
    **Examples:**\n```bash\n# Process one at a time\necho \"1 2 3 4\" | xargs -n1\
    \ echo \"Number:\"\n\n# Parallel execution\nfind . -name \"*.jpg\" | xargs -P\
    \ 4 -I {} convert {} {}.png\n\n# Prompt for confirmation\nfind . -name \"*.bak\"\
    \ | xargs -p rm\n```\n\n**Handling special characters:**\n```bash\n# Files with\
    \ spaces or special chars\nfind . -name \"*.txt\" -print0 | xargs -0 rm\n# -print0\
    \ uses null separator, -0 expects null separator\n```\n\n**Task:** Explore xargs\
    \ options.\n\n```bash\ncd ~/cmdline\n\n# Create more test files\nmkdir xargs_test\n\
    for i in {1..10}; do\n  echo \"Data $i\" > xargs_test/file$i.txt\ndone\n\n# Document\
    \ xargs options\necho \"Advanced xargs Options\" > xargs_advanced.txt\necho \"\
    ======================\" >> xargs_advanced.txt\necho \"\" >> xargs_advanced.txt\n\
    \necho \"Process files one at a time (-n1):\" >> xargs_advanced.txt\nls xargs_test/*.txt\
    \ | head -3 | xargs -n1 echo \"Processing:\" >> xargs_advanced.txt\n\necho \"\"\
    \ >> xargs_advanced.txt\necho \"Using placeholder (-I {}):\" >> xargs_advanced.txt\n\
    ls xargs_test/*.txt | head -3 | xargs -I {} echo \"File: {} Size: $(stat -f%z\
    \ {} 2>/dev/null || stat -c%s {})\" >> xargs_advanced.txt\n\necho \"\" >> xargs_advanced.txt\n\
    echo \"Verbose mode (-t) shows commands:\" >> xargs_advanced.txt\necho \"file1\
    \ file2\" | xargs -t echo \"Processing:\" >> xargs_advanced.txt 2>&1 | head -2\n\
    \ncat xargs_advanced.txt\n```\n"
  hint: '-n controls how many arguments per execution, -I {} lets you place the

    argument anywhere in the command. -P enables parallel execution.

    '
  validation:
    type: file-exists
    path: ~/cmdline/xargs_advanced.txt
    matcher: exists
  title: '**Advanced xargs Options**'
- id: parallel-execution
  description: "**Parallel Command Execution**\n\n**Using xargs -P:**\n```bash\n#\
    \ Run 4 processes in parallel\nfind . -name \"*.jpg\" | xargs -P 4 -I {} convert\
    \ {} {}.thumbnail.jpg\n\n# CPU-intensive tasks\nseq 1 100 | xargs -P $(nproc)\
    \ -I {} sh -c 'echo \"Processing {}\"'\n```\n\n**Using GNU parallel (if available):**\n\
    ```bash\n# More powerful than xargs -P\nparallel echo \"Processing {}\" ::: file1\
    \ file2 file3\n\n# With multiple CPUs\nparallel -j 4 gzip ::: *.log\n\n# Progress\
    \ bar\nparallel --progress gzip ::: *.log\n```\n\n**Task:** Practice parallel\
    \ execution.\n\n```bash\ncd ~/cmdline\n\n# Create work files\nmkdir parallel_test\n\
    for i in {1..8}; do\n  echo \"Task $i data\" > parallel_test/task$i.txt\ndone\n\
    \n# Document parallel execution\necho \"Parallel Execution\" > parallel_demo.txt\n\
    echo \"==================\" >> parallel_demo.txt\necho \"\" >> parallel_demo.txt\n\
    \necho \"Sequential processing (one at a time):\" >> parallel_demo.txt\ntime_start=$(date\
    \ +%s)\nls parallel_test/*.txt | xargs -n1 -I {} sh -c 'sleep 0.1; echo \"Done:\
    \ {}\"' > /dev/null\ntime_end=$(date +%s)\necho \"  Time: $((time_end - time_start))\
    \ seconds\" >> parallel_demo.txt\n\necho \"\" >> parallel_demo.txt\necho \"Parallel\
    \ processing (4 at a time with xargs -P):\" >> parallel_demo.txt\ntime_start=$(date\
    \ +%s)\nls parallel_test/*.txt | xargs -P 4 -I {} sh -c 'sleep 0.1; echo \"Done:\
    \ {}\"' > /dev/null\ntime_end=$(date +%s)\necho \"  Time: $((time_end - time_start))\
    \ seconds (faster!)\" >> parallel_demo.txt\n\necho \"\" >> parallel_demo.txt\n\
    echo \"Benefits of parallel execution:\" >> parallel_demo.txt\necho \"- Faster\
    \ processing of independent tasks\" >> parallel_demo.txt\necho \"- Better CPU\
    \ utilization\" >> parallel_demo.txt\necho \"- Useful for batch operations (compression,\
    \ image processing, etc.)\" >> parallel_demo.txt\n\ncat parallel_demo.txt\n```\n"
  hint: 'Use -P to run multiple commands in parallel. Set it to the number of CPU

    cores (use ''nproc'' to get count) for optimal performance.

    '
  validation:
    type: file-exists
    path: ~/cmdline/parallel_demo.txt
    matcher: exists
  title: '**Parallel Command Execution**'
- id: complex-pipelines
  description: "**Building Complex Command Pipelines**\n\n**Combining multiple commands:**\n\
    ```bash\n# Find large files, sort, show top 10\nfind /var/log -type f -exec du\
    \ -h {} \\; | sort -rh | head -10\n\n# Find and process\nfind . -name \"*.log\"\
    \ |\n  xargs grep \"ERROR\" |\n  cut -d: -f1 |\n  sort -u |\n  xargs -I {} echo\
    \ \"Error found in: {}\"\n```\n\n**Using tee for branching:**\n```bash\n# Save\
    \ and display simultaneously\ncommand | tee output.txt | grep \"pattern\"\n\n\
    # Multiple outputs\ncommand | tee file1.txt | grep \"error\" | tee file2.txt\n\
    ```\n\n**Process substitution:**\n```bash\n# Compare outputs of two commands\n\
    diff <(command1) <(command2)\n\n# Use command output as file\nwhile read line;\
    \ do echo \"$line\"; done < <(find . -name \"*.txt\")\n```\n\n**Task:** Build\
    \ complex pipelines.\n\n```bash\ncd ~/cmdline\n\n# Create log files with various\
    \ content\nmkdir logs\necho \"INFO: Application started\" > logs/app1.log\necho\
    \ \"ERROR: Connection failed\" >> logs/app1.log\necho \"INFO: Processing request\"\
    \ > logs/app2.log\necho \"ERROR: Database timeout\" >> logs/app2.log\necho \"\
    ERROR: Invalid input\" >> logs/app2.log\necho \"INFO: Request completed\" > logs/app3.log\n\
    \n# Complex pipeline examples\necho \"Complex Command Pipelines\" > pipelines.txt\n\
    echo \"=========================\" >> pipelines.txt\necho \"\" >> pipelines.txt\n\
    \necho \"Example 1: Find ERROR lines, extract files, count:\" >> pipelines.txt\n\
    find logs -name \"*.log\" -exec grep -l \"ERROR\" {} \\; |\n  tee -a pipelines.txt\
    \ |\n  xargs -I {} echo \"  {}\" >> pipelines.txt\n\necho \"\" >> pipelines.txt\n\
    echo \"Example 2: Count errors per file:\" >> pipelines.txt\nfind logs -name \"\
    *.log\" |\n  xargs -I {} sh -c 'echo \"{}: $(grep -c ERROR {})\"' >> pipelines.txt\n\
    \necho \"\" >> pipelines.txt\necho \"Example 3: Extract and summarize all ERROR\
    \ messages:\" >> pipelines.txt\nfind logs -name \"*.log\" -exec grep \"ERROR\"\
    \ {} \\; |\n  cut -d: -f2- |\n  sort |\n  uniq -c |\n  sort -rn >> pipelines.txt\n\
    \ncat pipelines.txt\n```\n"
  hint: 'Chain commands with | (pipe). Use tee to save intermediate results.

    Process substitution <(command) treats command output as a file.

    '
  validation:
    type: file-exists
    path: ~/cmdline/pipelines.txt
    matcher: exists
  title: '**Building Complex Command Pipelines**'
- id: argument-parsing-scripts
  description: "**Parsing Arguments in Shell Scripts**\n\n**Basic argument handling:**\n\
    ```bash\n#!/bin/bash\n# $0 = script name\n# $1, $2, ... = arguments\n# $# = number\
    \ of arguments\n# $@ = all arguments\n# $* = all arguments as single string\n\n\
    echo \"Script: $0\"\necho \"First arg: $1\"\necho \"All args: $@\"\necho \"Count:\
    \ $#\"\n```\n\n**Using getopts for options:**\n```bash\n#!/bin/bash\nwhile getopts\
    \ \"f:v\" opt; do\n  case $opt in\n    f) file=\"$OPTARG\" ;;\n    v) verbose=true\
    \ ;;\n    \\?) echo \"Invalid option\" ;;\n  esac\ndone\n\n# Usage: script.sh\
    \ -f filename -v\n```\n\n**Task:** Create argument parsing script.\n\n```bash\n\
    cd ~/cmdline\n\n# Create argument parsing script\ncat > parse_args.sh << 'EOF'\n\
    #!/bin/bash\n# Argument parsing demonstration\n\n# Default values\nverbose=false\n\
    output_file=\"\"\naction=\"help\"\n\n# Parse options\nwhile getopts \"vho:a:\"\
    \ opt; do\n  case $opt in\n    v)\n      verbose=true\n      ;;\n    h)\n    \
    \  echo \"Usage: $0 [-v] [-o output] [-a action]\"\n      echo \"  -v        \
    \  Verbose mode\"\n      echo \"  -o FILE     Output file\"\n      echo \"  -a\
    \ ACTION   Action to perform\"\n      exit 0\n      ;;\n    o)\n      output_file=\"\
    $OPTARG\"\n      ;;\n    a)\n      action=\"$OPTARG\"\n      ;;\n    \\?)\n  \
    \    echo \"Invalid option: -$OPTARG\"\n      exit 1\n      ;;\n  esac\ndone\n\
    \n# Show parsed values\necho \"Parsed Arguments:\"\necho \"  Verbose: $verbose\"\
    \necho \"  Output: ${output_file:-none}\"\necho \"  Action: $action\"\necho \"\
    \  Remaining args: ${@:$OPTIND}\"\nEOF\n\nchmod +x parse_args.sh\n\n# Test the\
    \ script\necho \"Argument Parsing Scripts\" > arg_parsing.txt\necho \"========================\"\
    \ >> arg_parsing.txt\necho \"\" >> arg_parsing.txt\n\necho \"Test 1: ./parse_args.sh\
    \ -v -o output.txt -a process\" >> arg_parsing.txt\n./parse_args.sh -v -o output.txt\
    \ -a process >> arg_parsing.txt\n\necho \"\" >> arg_parsing.txt\necho \"Test 2:\
    \ ./parse_args.sh -h\" >> arg_parsing.txt\n./parse_args.sh -h >> arg_parsing.txt\
    \ 2>&1 | head -5\n\ncat arg_parsing.txt\n```\n"
  hint: 'getopts processes options one at a time. Use a case statement to handle

    each option. $OPTARG contains the option''s value.

    '
  validation:
    type: file-exists
    path: ~/cmdline/arg_parsing.txt
    matcher: exists
  title: '**Parsing Arguments in Shell Scripts**'
- id: real-world-automation
  description: "**Real-World Automation Examples**\n\n**Batch file processing:**\n\
    ```bash\n# Convert all JPG to PNG in parallel\nfind . -name \"*.jpg\" | xargs\
    \ -P 4 -I {} bash -c '\n  convert \"{}\" \"${{}%.jpg}.png\"\n  echo \"Converted:\
    \ {}\"\n'\n```\n\n**Log analysis:**\n```bash\n# Find most common errors\nfind\
    \ /var/log -name \"*.log\" |\n  xargs grep \"ERROR\" |\n  cut -d: -f3- |\n  sort\
    \ |\n  uniq -c |\n  sort -rn |\n  head -10\n```\n\n**Batch renaming:**\n```bash\n\
    # Rename files to lowercase\nfind . -name \"*.TXT\" |\n  xargs -I {} bash -c '\n\
    \    mv \"{}\" \"$(echo {} | tr A-Z a-z)\"\n  '\n```\n\n**Task:** Create automation\
    \ examples.\n\n```bash\ncd ~/cmdline\n\n# Create automation scenarios\nmkdir automation\n\
    cd automation\n\n# Scenario 1: Batch file organization\nmkdir -p {images,documents,archives}\n\
    touch file1.jpg file2.png file3.txt file4.pdf file5.zip\n\n# Create organization\
    \ script\ncat > organize.sh << 'EOF'\n#!/bin/bash\n# Organize files by type\n\n\
    echo \"Organizing files...\"\n\n# Move images\nfind . -maxdepth 1 -type f \\(\
    \ -name \"*.jpg\" -o -name \"*.png\" \\) |\n  xargs -I {} mv {} images/ 2>/dev/null\n\
    \n# Move documents\nfind . -maxdepth 1 -type f \\( -name \"*.txt\" -o -name \"\
    *.pdf\" \\) |\n  xargs -I {} mv {} documents/ 2>/dev/null\n\n# Move archives\n\
    find . -maxdepth 1 -type f -name \"*.zip\" |\n  xargs -I {} mv {} archives/ 2>/dev/null\n\
    \necho \"Organization complete!\"\nls -R\nEOF\n\nchmod +x organize.sh\n\n# Document\
    \ automation\ncd ~/cmdline\necho \"Real-World Automation\" > automation_demo.txt\n\
    echo \"=====================\" >> automation_demo.txt\necho \"\" >> automation_demo.txt\n\
    \necho \"File organization script created\" >> automation_demo.txt\necho \"Running\
    \ organization...\" >> automation_demo.txt\ncd automation && ./organize.sh >>\
    \ ~/cmdline/automation_demo.txt 2>&1\n\ncd ~/cmdline\ncat automation_demo.txt\n\
    ```\n\n**Congratulations!** You've mastered command-line automation!\n\n**You\
    \ learned:**\n- xargs for converting stdin to arguments\n- Advanced xargs options\
    \ (-n, -I, -P)\n- Parallel command execution\n- Building complex command pipelines\n\
    - Argument parsing with getopts\n- Real-world automation patterns\n\n**Key techniques:**\n\
    - Use xargs to bridge commands\n- Parallelize for performance (-P flag)\n- Chain\
    \ commands with pipes\n- Parse arguments professionally with getopts\n- Automate\
    \ repetitive tasks with scripts\n\n**Best practices:**\n- Test commands before\
    \ adding to scripts\n- Use -print0 and -0 for files with spaces\n- Add error handling\
    \ to production scripts\n- Document complex pipelines\n- Use parallel processing\
    \ for CPU-intensive tasks\n\nYou can now build sophisticated command-line automation!\n"
  hint: 'Combine find, xargs, and shell scripting for powerful automation.

    Always test with a small dataset first before processing everything.

    '
  validation:
    type: file-exists
    path: ~/cmdline/automation_demo.txt
    matcher: exists
  title: '**Real-World Automation Examples**'
completion:
  message: Congratulations! You've completed this advanced mission.
  xp: 550
  unlocks: []
