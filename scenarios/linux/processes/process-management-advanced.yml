mission:
  id: linux/processes/process-management-advanced
  title: Advanced Process Management and Job Control
  difficulty: advanced
  description: Master Linux processes, jobs, signals, and system resource management
  estimated_time: 65
  tags:
  - linux
  - processes
  - jobs
  - signals
  - advanced
environment:
  image: ubuntu:22.04
  workdir: /home/learner
  setup:
  - mkdir -p /home/learner/scripts
  - apt-get update -qq && apt-get install -y -qq procps htop stress bc
  - "cat > /home/learner/scripts/long_task.sh << 'EOF'\n#!/bin/bash\necho \"Starting\
    \ long task (PID: $$)\"\nfor i in {1..60}; do\n  echo \"Working... iteration $i\"\
    \n  sleep 2\ndone\necho \"Task completed!\"\nEOF\n"
  - chmod +x /home/learner/scripts/long_task.sh
  - "cat > /home/learner/scripts/cpu_intensive.sh << 'EOF'\n#!/bin/bash\necho \"CPU\
    \ intensive task starting (PID: $$)\"\nwhile true; do\n  echo \"scale=5000; a(1)*4\"\
    \ | bc -l > /dev/null\ndone\nEOF\n"
  - chmod +x /home/learner/scripts/cpu_intensive.sh
steps:
- id: view-processes-ps
  title: View Processes with ps Command
  description: '**Understanding Processes:**


    A process is a running instance of a program. Every process has:

    - PID (Process ID) - unique number

    - PPID (Parent Process ID) - who started it

    - Owner (user)

    - Priority and nice value

    - Resource usage (CPU, memory)

    - State (running, sleeping, stopped, zombie)


    **The ps Command:**


    Basic usage:

    ps          # Processes in current terminal

    ps aux      # All processes, detailed

    ps -ef      # All processes, full format


    **Understanding ps aux output:**

    USER  PID %CPU %MEM    VSZ   RSS TTY STAT START TIME COMMAND

    root    1  0.0  0.1  16988  1234  ?  Ss   10:00 0:00 /sbin/init


    - USER: Owner

    - PID: Process ID

    - %CPU: CPU usage percentage

    - %MEM: Memory usage percentage

    - VSZ: Virtual memory size

    - RSS: Resident set size (actual RAM)

    - TTY: Terminal (? = no terminal)

    - STAT: State (R=running, S=sleeping, D=disk sleep, Z=zombie)

    - START: Start time

    - TIME: CPU time used

    - COMMAND: Command that started process


    **Try it:**

    ps aux | head -n 20

    ps -ef | grep bash

    ps --forest  # Show process tree

    '
  hint: 'Type: ps aux | head -n 20 to see running processes'
  validation:
    type: command-output
    command: ps aux | head -n 1
    matcher: contains
    expected: USER
- id: process-hierarchy
  title: Understand Process Hierarchy and Trees
  description: '**Process Family Tree:**


    All processes form a tree starting with PID 1 (init/systemd).


    **View Process Tree:**

    ps --forest

    pstree

    pstree -p   # Show PIDs


    **Parent-Child Relationships:**


    When you run a command from bash:

    1. Bash is the parent (PPID)

    2. Command becomes child process (PID)

    3. Child inherits environment from parent


    **Find Process Ancestry:**


    Current shell''s PID:

    echo $$


    Parent of current shell:

    ps -o ppid= -p $$


    Full ancestry:

    ps -o pid,ppid,cmd -p $$


    **Orphan Processes:**


    If parent dies, children get adopted by init (PID 1).


    **Try it:**

    # Your shell''s PID

    echo "My shell PID: $$"


    # Start a process

    sleep 100 &

    SLEEP_PID=$!


    # Check its parent

    ps -o pid,ppid,cmd -p $SLEEP_PID


    # PPID should be $$ (your shell)


    # Clean up

    kill $SLEEP_PID

    '
  hint: 'Use: echo $$ to see your PID, pstree to see tree, ps -p PID to see specific
    process'
  validation:
    type: command-output
    command: echo $$ | grep -E '^[0-9]+$'
    matcher: contains
    expected: ''
- id: background-jobs
  title: Run Jobs in Background
  description: '**Foreground vs Background:**


    - Foreground: Command blocks terminal until done

    - Background: Command runs, terminal stays usable


    **Start in Background:**


    Add & at end:

    sleep 30 &


    Terminal returns immediately with:

    [1] 12345

    - [1] = job number

    - 12345 = PID


    **List Background Jobs:**

    jobs


    Output:

    [1]+  Running    sleep 30 &


    **Run Long Task in Background:**

    ~/scripts/long_task.sh &


    Check it''s running:

    jobs

    ps aux | grep long_task


    **Background Job Advantages:**

    - Terminal remains usable

    - Multiple tasks run concurrently

    - Can manage independently


    **Try it:**

    sleep 100 &

    sleep 200 &

    jobs

    # Should see both jobs listed

    '
  hint: 'Run: sleep 60 & then jobs to see background jobs'
  validation:
    type: command-output
    command: sleep 1 & jobs | grep sleep
    matcher: contains
    expected: sleep
- id: job-control
  title: 'Control Jobs: fg, bg, Ctrl+Z'
  description: '**Job Control Commands:**


    **Suspend Foreground Job:**

    Run: sleep 60

    Press: Ctrl+Z

    Job suspended (stopped, not terminated)


    **Resume in Background:**

    bg %1

    # or just: bg


    Job continues in background.


    **Bring to Foreground:**

    fg %1

    # or just: fg


    Job returns to foreground.


    **Job Specifiers:**

    %1      - Job number 1

    %+      - Current job (most recent)

    %-      - Previous job

    %sleep  - Job matching "sleep"

    %%      - Current job


    **Practical Example:**


    # Start long task

    ~/scripts/long_task.sh


    # Suspend it (Ctrl+Z)

    ^Z


    # See suspended jobs

    jobs


    # Resume in background

    bg %1


    # Bring back to foreground

    fg %1


    # Or terminate it

    Ctrl+C


    **Try it:**

    sleep 60    # Press Ctrl+Z after starting

    jobs        # See it''s stopped

    bg          # Resume in background

    jobs        # See it''s running

    fg          # Bring to foreground

    # Press Ctrl+C to terminate

    '
  hint: 'Start: sleep 60, press Ctrl+Z, then: bg, jobs, fg'
  validation:
    type: command-output
    command: jobs | wc -l
    matcher: contains
    expected: '0'
- id: signals-kill
  title: Send Signals to Processes
  description: "**Process Signals:**\n\nSignals are asynchronous notifications sent\
    \ to processes.\n\n**Common Signals:**\n- SIGTERM (15): Polite termination request\
    \ (default)\n- SIGKILL (9): Forceful kill (cannot be ignored)\n- SIGSTOP (19):\
    \ Suspend process\n- SIGCONT (18): Resume suspended process\n- SIGHUP (1): Hangup\
    \ (terminal closed)\n- SIGINT (2): Interrupt (Ctrl+C)\n\n**The kill Command:**\n\
    \nSend signal to PID:\nkill PID          # Sends SIGTERM (15)\nkill -9 PID   \
    \    # Sends SIGKILL (9)\nkill -TERM PID    # Sends SIGTERM (name)\nkill -l  \
    \         # List all signals\n\n**Practice Scenarios:**\n\n1. **Graceful termination:**\n\
    \   sleep 100 &\n   PID=$!\n   kill $PID      # Sends SIGTERM\n   jobs       \
    \    # Job terminates\n\n2. **Forceful kill:**\n   sleep 100 &\n   PID=$!\n  \
    \ kill -9 $PID   # Immediate termination\n   jobs           # Job killed\n\n3.\
    \ **Kill by job number:**\n   sleep 100 &\n   kill %1        # Kills job 1\n\n\
    **killall - Kill by Name:**\nkillall sleep      # Kills ALL processes named \"\
    sleep\"\nkillall -9 sleep   # Force kill all sleep processes\n\n**pkill - Pattern\
    \ Kill:**\npkill -f long_task # Kills processes matching pattern\n\n**Safety Warning:**\n\
    Always use SIGTERM first (graceful).\nOnly use SIGKILL (-9) if process won't respond.\n"
  hint: 'Start: sleep 60 &, get PID: echo $!, then: kill $PID'
  validation:
    type: command-output
    command: kill -l | grep TERM
    matcher: contains
    expected: TERM
- id: process-priorities
  title: Manage Process Priority with nice and renice
  description: '**Process Priority:**


    Linux uses "niceness" to control process priority.


    **Nice Values:**

    - Range: -20 (highest priority) to +19 (lowest)

    - Default: 0

    - Lower value = higher priority

    - Only root can use negative values


    **Start Process with Priority:**


    nice -n 10 command      # Lower priority (+10)

    nice -n -5 command      # Higher priority (root only)


    **Check Process Priority:**

    ps -l                   # Shows NI (nice) column

    ps -eo pid,ni,comm      # Custom format


    **Change Running Process Priority:**


    renice 10 -p PID        # Set to nice=10

    renice -5 -p PID        # Set to nice=-5 (root only)


    **Practical Example:**


    # Start CPU-intensive task with low priority

    nice -n 19 ~/scripts/cpu_intensive.sh &

    CPU_PID=$!


    # Check its priority

    ps -o pid,ni,comm -p $CPU_PID


    # Adjust priority

    renice 10 -p $CPU_PID


    # Verify change

    ps -o pid,ni,comm -p $CPU_PID


    # Clean up

    kill $CPU_PID


    **Use Cases:**


    - Background backups: nice -n 19

    - Batch processing: nice -n 10

    - Critical real-time tasks: nice -n -10 (root)


    **Try it:**

    nice -n 15 sleep 60 &

    ps -o pid,ni,comm | grep sleep

    # Should show NI=15

    '
  hint: 'Run: nice -n 10 sleep 60 &, then: ps -o pid,ni,comm | grep sleep'
  validation:
    type: command-output
    command: nice -n 10 sleep 1 & ps -o ni,comm | grep sleep | awk '{print $1}'
    matcher: contains
    expected: '10'
- id: monitor-processes-top
  title: Monitor Processes in Real-Time with top
  description: '**The top Command:**


    Interactive real-time process monitoring.


    **Start top:**

    top


    **Understanding top Display:**


    Header shows:

    - Uptime

    - Users logged in

    - Load average (1, 5, 15 minutes)

    - CPU usage breakdown

    - Memory and swap usage


    Process list shows:

    - PID, USER, PR, NI, VIRT, RES, SHR, %CPU, %MEM, TIME+, COMMAND


    **Interactive Commands (while in top):**

    - q: Quit

    - h: Help

    - k: Kill a process (enter PID)

    - r: Renice (change priority)

    - M: Sort by memory

    - P: Sort by CPU

    - u: Filter by user

    - 1: Show individual CPUs

    - f: Choose displayed fields

    - d: Change update delay

    - z: Color mode


    **Useful Filtering:**


    top -u learner     # Show only learner''s processes

    top -p PID         # Monitor specific PID

    top -n 1 -b        # Batch mode (one iteration)


    **Alternative: htop (if available):**


    More user-friendly with:

    - Colors

    - Mouse support

    - Tree view

    - Easy sorting


    Try: htop


    **For quick snapshot:**

    top -n 1 -b | head -n 20

    '
  hint: 'Run: top (press q to quit), or: top -n 1 -b | head -n 20'
  validation:
    type: command-output
    command: top -n 1 -b | head -n 1
    matcher: contains
    expected: top
- id: cpu-memory-usage
  title: Analyze CPU and Memory Usage
  description: '**Find High CPU Processes:**


    Top 10 by CPU:

    ps aux --sort=-%cpu | head -n 11


    **Find High Memory Processes:**


    Top 10 by memory:

    ps aux --sort=-%mem | head -n 11


    **Process-Specific Information:**


    Detailed info about process:

    cat /proc/PID/status

    cat /proc/PID/cmdline

    cat /proc/PID/limits


    **Monitor Specific Process:**


    Watch a process''s resources:

    watch -n 1 ''ps -o pid,pcpu,pmem,cmd -p PID''


    **System-Wide Statistics:**


    CPU info:

    cat /proc/cpuinfo | grep "model name" | head -n 1


    Memory info:

    cat /proc/meminfo | grep -E "MemTotal|MemAvailable"


    **Load Average:**


    Current system load:

    uptime

    cat /proc/loadavg


    Load average interpretation:

    - < # of CPUs: System is fine

    - = # of CPUs: System is busy

    - > # of CPUs: System is overloaded


    **Test with Stress:**


    Create CPU load:

    stress --cpu 2 --timeout 30 &


    Monitor:

    top


    The stress process should show high CPU usage.

    '
  hint: 'See CPU hogs: ps aux --sort=-%cpu | head -n 11'
  validation:
    type: command-output
    command: ps aux --sort=-%cpu | head -n 1
    matcher: contains
    expected: USER
- id: zombie-processes
  title: Understand and Handle Zombie Processes
  description: '**What is a Zombie Process?**


    A zombie (defunct) process:

    - Has finished execution

    - Still has entry in process table

    - Waiting for parent to read exit status

    - Shows as <defunct> in ps

    - State code: Z


    **Why Zombies Exist:**


    1. Child process exits

    2. Parent should call wait() to read exit status

    3. If parent doesn''t, child becomes zombie

    4. When parent exits, init adopts and cleans zombies


    **Find Zombies:**


    ps aux | grep ''Z''

    ps aux | grep defunct

    ps -eo pid,stat,cmd | grep ''^[0-9]* Z''


    **Zombie vs Normal Process:**


    Normal:

    - Uses resources (CPU, memory)

    - Can be killed with SIGKILL

    - Running or sleeping


    Zombie:

    - Uses NO resources (only PID table entry)

    - Cannot be killed (already dead!)

    - Only parent or reboot removes it


    **How to Remove Zombies:**


    Option 1: Kill the parent (if possible)

    ps -o ppid= -p ZOMBIE_PID

    kill PARENT_PID


    Parent''s death causes init to adopt and clean zombie.


    Option 2: Wait for parent to clean up


    Option 3: Reboot (last resort)


    **Prevention:**


    Proper programming:

    - Parent calls wait() or waitpid()

    - Use signal handler for SIGCHLD

    - Double-fork technique


    **Zombies are Usually Harmless:**

    - Don''t consume resources

    - Only waste a PID

    - Indicate bug in parent process


    **Check for Zombies Now:**

    ps aux | awk ''$8 == "Z" {print}''

    '
  hint: 'Find zombies: ps aux | grep defunct or ps -eo stat,pid,cmd | grep ''^Z'''
  validation:
    type: command-output
    command: ps aux | awk 'NR==1 || $8 ~ /Z/ {print}' | head -n 1
    matcher: contains
    expected: USER
- id: process-substitution
  title: Use Process Substitution for Complex Pipelines
  description: "**Process Substitution:**\n\nTreat command output as a file.\n\n**Syntax:**\n\
    <(command)  - Output as readable file\n>(command)  - Input as writable file\n\n\
    **Example 1: Compare Command Outputs**\n\nCompare process lists:\ndiff <(ps aux)\
    \ <(ps aux)\n\nCompare sorted files:\ndiff <(sort file1.txt) <(sort file2.txt)\n\
    \n**Example 2: Multiple Inputs**\n\nCombine outputs:\npaste <(ls -1 /bin) <(ls\
    \ -1 /sbin)\n\n**Example 3: Parallel Processing**\n\nProcess data from multiple\
    \ sources:\nwhile read line; do\n  echo \"Processing: $line\"\ndone < <(ps aux\
    \ | awk '{print $2}')\n\n**Real-World Use:**\n\nMonitor differences:\nwatch -n\
    \ 1 'diff <(ps aux | grep sleep) <(echo \"Baseline\")'\n\nCompare system states:\n\
    diff <(lsof | wc -l) <(sleep 2 && lsof | wc -l)\n\n**Try it:**\n# Compare directory\
    \ listings\ndiff <(ls -1 /bin | head -n 5) <(ls -1 /usr/bin | head -n 5)\n"
  hint: 'Try: diff <(ps aux | head -n 5) <(ps aux | head -n 5)'
  validation:
    type: command-output
    command: cat <(echo 'test')
    matcher: exact
    expected: test
- id: practical-scenarios
  title: Apply Process Management Skills
  description: '**Scenario 1: Runaway Process**


    Find and kill process using too much CPU:


    # Find process

    ps aux --sort=-%cpu | head -n 5


    # Get PID

    PID=$(ps aux --sort=-%cpu | awk ''NR==2 {print $2}'')


    # Try graceful termination

    kill $PID


    # If not responsive after 10 seconds

    sleep 10

    kill -9 $PID


    **Scenario 2: Background Long-Running Task**


    Run maintenance script in background with low priority:


    nohup nice -n 19 ~/scripts/long_task.sh > /tmp/task.log 2>&1 &


    - nohup: Continue running after logout

    - nice -n 19: Lowest priority

    - > /tmp/task.log: Redirect output

    - 2>&1: Redirect stderr to stdout

    - &: Run in background


    Check progress:

    tail -f /tmp/task.log


    **Scenario 3: System Overload Investigation**


    # Check load average

    uptime


    # Find CPU hogs

    ps aux --sort=-%cpu | head -n 10


    # Find memory hogs

    ps aux --sort=-%mem | head -n 10


    # Detailed monitoring

    top


    # Check specific process

    PID=1234

    ps -o pid,pcpu,pmem,etime,cmd -p $PID


    **Scenario 4: Graceful Service Restart**


    # Send HUP signal (reload config)

    kill -HUP SERVICE_PID


    # Or restart entirely

    kill -TERM SERVICE_PID

    # Wait for cleanup

    sleep 5

    # Start new instance

    /path/to/service &


    **Practice:**

    Choose a scenario and implement it!

    '
  hint: Pick a scenario and work through it step by step
  validation:
    type: command-output
    command: uptime | grep -o 'load average'
    matcher: contains
    expected: load average
completion:
  message: 'ðŸŽ¯ PROCESS MANAGEMENT MASTERY ACHIEVED! ðŸŽ¯


    You''ve mastered advanced Linux process management!


    **Core Concepts Mastered:**


    âœ“ Process fundamentals (PID, PPID, states)

    âœ“ Process hierarchy and trees

    âœ“ Background and foreground jobs

    âœ“ Job control (fg, bg, Ctrl+Z)

    âœ“ Process signals (SIGTERM, SIGKILL, etc.)

    âœ“ Process priorities (nice, renice)

    âœ“ Real-time monitoring (ps, top, htop)

    âœ“ Resource usage analysis

    âœ“ Zombie processes

    âœ“ Process substitution

    âœ“ Practical troubleshooting


    **Commands You''ve Mastered:**


    - ps (process status)

    - jobs (list jobs)

    - fg / bg (job control)

    - kill / killall / pkill (signals)

    - nice / renice (priority)

    - top / htop (monitoring)

    - pstree (process tree)

    - nohup (persist after logout)


    **Process States:**

    - R: Running

    - S: Sleeping

    - D: Uninterruptible sleep (disk)

    - Z: Zombie

    - T: Stopped


    **Signal Summary:**

    - SIGTERM (15): Graceful shutdown

    - SIGKILL (9): Immediate kill

    - SIGSTOP (19): Suspend

    - SIGCONT (18): Resume

    - SIGHUP (1): Reload config


    **Real-World Skills:**


    â˜‘ Troubleshoot runaway processes

    â˜‘ Manage long-running tasks

    â˜‘ Optimize system performance

    â˜‘ Monitor system health

    â˜‘ Handle process issues

    â˜‘ Background job management

    â˜‘ Resource allocation


    You''re now ready for:

    - System administration

    - Performance tuning

    - DevOps operations

    - Troubleshooting production issues


    EXCELLENT WORK!

    '
  xp: 550
  unlocks:
  - linux/week10/cron-automation-advanced
  - linux/week10/practice-process-investigation
