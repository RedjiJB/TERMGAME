mission:
  id: shell-config-intermediate
  title: Shell Configuration and PATH Management
  difficulty: intermediate
  description: 'Master shell configuration files and PATH management. Learn about
    .bashrc,

    .bash_profile, and how to customize your shell environment permanently.


    Essential skills for creating a personalized and efficient command-line environment!

    '
  estimated_time: 35
  xp_reward: 300
  tags:
  - shell
  - bashrc
  - configuration
  - PATH
  - week5
environment:
  setup:
  - apt-get update && apt-get install -y \
  - bash \
  - vim \
  - coreutils
  image: ubuntu:22.04
steps:
- id: understand-shell-config
  description: "**Shell Configuration Files**\n\nWhen bash starts, it reads configuration\
    \ files to set up your environment.\n\n**Login shells read (in order):**\n1. `/etc/profile`\
    \ (system-wide)\n2. `~/.bash_profile` OR `~/.bash_login` OR `~/.profile` (first\
    \ found)\n3. `~/.bash_logout` (on exit)\n\n**Interactive non-login shells read:**\n\
    1. `/etc/bash.bashrc` (system-wide)\n2. `~/.bashrc` (user-specific)\n\n**Common\
    \ practice:**\n- Put environment variables in `~/.bash_profile`\n- Put aliases\
    \ and functions in `~/.bashrc`\n- Have `.bash_profile` source `.bashrc` for consistency\n\
    \n**Check what you have:**\n```bash\nmkdir -p ~/shell_config\ncd ~/shell_config\n\
    \n# Check for config files\necho \"Configuration files:\" > config_files.txt\n\
    for file in ~/.bashrc ~/.bash_profile ~/.profile; do\n  if [ -f \"$file\" ]; then\n\
    \    echo \"✓ $file exists\" >> config_files.txt\n  else\n    echo \"✗ $file not\
    \ found\" >> config_files.txt\n  fi\ndone\n\ncat config_files.txt\n```\n"
  hint: 'Most Ubuntu systems use ~/.bashrc for interactive shells. Check if it

    exists with ''ls -la ~/'' to see hidden files (starting with dot).

    '
  validation:
    type: file-exists
    path: ~/shell_config/config_files.txt
    matcher: exists
  title: '**Shell Configuration Files**'
- id: customize-bashrc
  description: "**Customizing .bashrc**\n\nLet's create a custom .bashrc with useful\
    \ settings.\n\n**Common customizations:**\n- Custom prompt (PS1)\n- Aliases for\
    \ common commands\n- Environment variables\n- Functions\n- PATH modifications\n\
    \n**Task:** Create a basic .bashrc\n\n```bash\n# Backup existing .bashrc if it\
    \ exists\n[ -f ~/.bashrc ] && cp ~/.bashrc ~/.bashrc.backup\n\n# Create our custom\
    \ .bashrc\ncat > ~/.bashrc << 'EOF'\n# Custom .bashrc for learning\n\n# If not\
    \ interactive, don't do anything\ncase $- in\n    *i*) ;;\n      *) return;;\n\
    esac\n\n# History settings\nHISTSIZE=1000\nHISTFILESIZE=2000\nHISTCONTROL=ignoredups:ignorespace\n\
    \n# Make less more friendly\nexport LESS='-R'\n\n# Colorful prompt\nPS1='\\[\\\
    033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ '\n\
    \n# Useful aliases\nalias ll='ls -lh'\nalias la='ls -lah'\nalias ..='cd ..'\n\
    alias ...='cd ../..'\n\n# Custom greeting\necho \"Welcome, $USER! Today is $(date\
    \ +%A)\"\nEOF\n\n# Source it to apply changes\nsource ~/.bashrc\n\n# Verify\n\
    echo \"Custom .bashrc created successfully\" > bashrc_created.txt\n```\n\nNote:\
    \ The welcome message will appear when you source .bashrc!\n"
  hint: 'Use ''source ~/.bashrc'' to reload the configuration without restarting

    the shell. The changes take effect immediately.

    '
  validation:
    type: file-exists
    path: ~/shell_config/bashrc_created.txt
    matcher: exists
  title: '**Customizing .bashrc**'
- id: alias-management
  description: "**Creating Useful Aliases**\n\nAliases are shortcuts for commands.\
    \ They're defined in .bashrc.\n\n**Syntax:**\n```bash\nalias name='command'\n\
    ```\n\n**Common useful aliases:**\n```bash\n# Safety aliases\nalias rm='rm -i'\
    \    # Confirm before deleting\nalias cp='cp -i'    # Confirm before overwriting\n\
    alias mv='mv -i'    # Confirm before overwriting\n\n# Convenience aliases\nalias\
    \ ll='ls -lh'              # Long listing, human-readable\nalias la='ls -lah'\
    \             # All files including hidden\nalias grep='grep --color=auto' # Colorful\
    \ grep\nalias df='df -h'               # Human-readable disk space\nalias du='du\
    \ -h'               # Human-readable disk usage\n\n# Navigation aliases\nalias\
    \ ..='cd ..'\nalias ...='cd ../..'\nalias ....='cd ../../..'\n\n# Git aliases\
    \ (if you use git)\nalias gs='git status'\nalias gl='git log --oneline'\nalias\
    \ gd='git diff'\n```\n\n**Task:** Add custom aliases to .bashrc\n\n```bash\n#\
    \ Add custom aliases section\ncat >> ~/.bashrc << 'EOF'\n\n# === Custom Aliases\
    \ ===\n\n# Safety first\nalias rm='rm -i'\nalias cp='cp -i'\nalias mv='mv -i'\n\
    \n# Enhanced ls\nalias ll='ls -lh'\nalias la='ls -lah'\nalias lt='ls -lht'  #\
    \ Sort by time\n\n# Quick navigation\nalias ..='cd ..'\nalias ...='cd ../..'\n\
    alias home='cd ~'\n\n# Disk usage\nalias df='df -h'\nalias du='du -h'\n\n# Process\
    \ management\nalias psg='ps aux | grep'\n\n# Custom function - make directory\
    \ and cd into it\nmkcd() {\n  mkdir -p \"$1\" && cd \"$1\"\n}\nEOF\n\n# Source\
    \ to apply\nsource ~/.bashrc\n\n# Test an alias\nalias ll > alias_test.txt\necho\
    \ \"\" >> alias_test.txt\necho \"Total aliases defined:\" >> alias_test.txt\n\
    alias | wc -l >> alias_test.txt\n\ncat alias_test.txt\n```\n"
  hint: 'Aliases are defined with ''alias name=command''. They persist across sessions

    when defined in .bashrc. Use ''alias'' without arguments to list all aliases.

    '
  validation:
    type: file-exists
    path: ~/shell_config/alias_test.txt
    matcher: exists
  title: '**Creating Useful Aliases**'
- id: path-modification
  description: "**Modifying the PATH Variable**\n\nOften you need to add directories\
    \ to PATH for custom scripts or programs.\n\n**Understanding PATH structure:**\n\
    ```\nPATH=/usr/local/bin:/usr/bin:/bin\n          ↑              ↑       ↑\n \
    \       First         Second   Third\n```\n\n**Adding to PATH:**\n\n**Append (add\
    \ to end):**\n```bash\nexport PATH=\"$PATH:/new/directory\"\n```\n\n**Prepend\
    \ (add to beginning - takes priority):**\n```bash\nexport PATH=\"/new/directory:$PATH\"\
    \n```\n\n**Task:** Create a personal bin directory and add it to PATH\n\n```bash\n\
    # Create personal bin directory\nmkdir -p ~/bin\n\n# Create a simple custom script\n\
    cat > ~/bin/hello << 'EOF'\n#!/bin/bash\necho \"Hello from custom script!\"\n\
    echo \"This is in my personal ~/bin directory\"\nEOF\n\nchmod +x ~/bin/hello\n\
    \n# Add ~/bin to PATH in .bashrc\ncat >> ~/.bashrc << 'EOF'\n\n# === Custom PATH\
    \ ===\n\n# Add personal bin to PATH if it exists\nif [ -d \"$HOME/bin\" ]; then\n\
    \  export PATH=\"$HOME/bin:$PATH\"\nfi\nEOF\n\n# Source to apply\nsource ~/.bashrc\n\
    \n# Document PATH changes\necho \"PATH Configuration:\" > path_config.txt\necho\
    \ \"==================\" >> path_config.txt\necho \"\" >> path_config.txt\necho\
    \ \"Current PATH:\" >> path_config.txt\necho \"$PATH\" | tr ':' '\\n' >> path_config.txt\n\
    echo \"\" >> path_config.txt\necho \"Testing custom command:\" >> path_config.txt\n\
    which hello >> path_config.txt\n\ncat path_config.txt\n```\n"
  hint: 'When adding to PATH, put ''$PATH'' in quotes and use colons (:) to separate

    directories. Prepend (dir:$PATH) gives priority, append ($PATH:dir) is last.

    '
  validation:
    type: file-exists
    path: ~/shell_config/path_config.txt
    matcher: exists
  title: '**Modifying the PATH Variable**'
- id: environment-in-bashrc
  description: '**Managing Environment Variables in .bashrc**


    You can set environment variables permanently in .bashrc.


    **Best practices:**

    ```bash

    # Application settings

    export EDITOR=vim

    export VISUAL=vim

    export PAGER=less


    # Development settings

    export GOPATH="$HOME/go"

    export JAVA_HOME="/usr/lib/jvm/java-11"


    # Custom application config

    export MY_APP_CONFIG="$HOME/.config/myapp"

    ```


    **Task:** Add environment variables to .bashrc


    ```bash

    # Add environment variables section

    cat >> ~/.bashrc << ''EOF''


    # === Environment Variables ===


    # Default programs

    export EDITOR=vim

    export PAGER=less


    # Custom settings

    export PRACTICE_DIR="$HOME/shell_config"

    export BACKUP_DIR="$HOME/backups"


    # Development

    export PROJECT_HOME="$HOME/projects"

    EOF


    # Source to apply

    source ~/.bashrc


    # Verify environment variables

    cat > env_vars.txt << EOF

    Environment Variables in .bashrc

    =================================


    EDITOR: $EDITOR

    PAGER: $PAGER

    PRACTICE_DIR: $PRACTICE_DIR

    BACKUP_DIR: $BACKUP_DIR

    PROJECT_HOME: $PROJECT_HOME

    EOF


    cat env_vars.txt

    ```

    '
  hint: 'Use ''export VAR=value'' in .bashrc to make environment variables permanent.

    They''ll be set every time you start a new shell session.

    '
  validation:
    type: file-exists
    path: ~/shell_config/env_vars.txt
    matcher: exists
  title: '**Managing Environment Variables in .bashrc**'
- id: bash-profile-integration
  description: "**Integrating .bash_profile and .bashrc**\n\nBest practice is to have\
    \ .bash_profile source .bashrc so settings are\nconsistent in all shell types.\n\
    \n**Standard pattern:**\n```bash\n# In ~/.bash_profile\n\n# Source .bashrc if\
    \ it exists\nif [ -f ~/.bashrc ]; then\n  source ~/.bashrc\nfi\n\n# Login-specific\
    \ settings here\nexport PATH=\"$PATH:/opt/bin\"\n```\n\n**Task:** Create .bash_profile\
    \ that sources .bashrc\n\n```bash\ncat > ~/.bash_profile << 'EOF'\n# .bash_profile\
    \ - Login shell configuration\n\n# Source .bashrc for common settings\nif [ -f\
    \ ~/.bashrc ]; then\n  source ~/.bashrc\nfi\n\n# Login-specific environment variables\n\
    # These run only once when you log in\n\n# Set default umask for file creation\n\
    umask 022\n\n# Login message\necho \"Login shell initialized\"\nEOF\n\n# Document\
    \ the setup\ncat > profile_setup.txt << 'EOF'\nShell Configuration Strategy\n\
    =============================\n\n.bash_profile (login shells):\n- Sourced when\
    \ you log in\n- Should source .bashrc\n- Login-specific settings (umask, etc.)\n\
    \n.bashrc (interactive shells):\n- Sourced for interactive shells\n- Aliases,\
    \ functions, prompts\n- Environment variables\n- PATH modifications\n\nBenefits\
    \ of this approach:\n- Consistent environment in all shells\n- Easy to maintain\
    \ (most settings in .bashrc)\n- Works for both login and non-login shells\nEOF\n\
    \ncat profile_setup.txt\n```\n"
  hint: 'The pattern ''if [ -f ~/.bashrc ]; then source ~/.bashrc; fi'' checks if

    .bashrc exists before sourcing it, preventing errors if the file is missing.

    '
  validation:
    type: file-exists
    path: ~/shell_config/profile_setup.txt
    matcher: exists
  title: '**Integrating .bash_profile and .bashrc**'
- id: testing-and-verification
  description: '**Testing Your Configuration**


    Let''s verify everything works correctly.


    **Test commands:**

    ```bash

    # Test aliases

    alias ll  # Should show the alias definition


    # Test functions

    type mkcd  # Should show it''s a function


    # Test environment variables

    echo $EDITOR

    echo $PRACTICE_DIR


    # Test PATH

    echo $PATH | grep "$HOME/bin"

    which hello  # Should find your custom script


    # Test custom script

    hello  # Should run and display message

    ```


    **Create comprehensive test:**

    ```bash

    cat > config_test.txt << EOF

    Shell Configuration Test Results

    =================================


    1. Aliases Test:

    $(alias ll 2>&1)


    2. Functions Test:

    $(type mkcd 2>&1 | head -1)


    3. Environment Variables:

    EDITOR=$EDITOR

    PRACTICE_DIR=$PRACTICE_DIR


    4. PATH Test:

    ~/bin in PATH: $(echo $PATH | grep -q "$HOME/bin" && echo "✓ Yes" || echo "✗ No")


    5. Custom Command Test:

    $(which hello 2>&1)


    6. Configuration Files:

    .bashrc: $([ -f ~/.bashrc ] && echo "✓ exists" || echo "✗ missing")

    .bash_profile: $([ -f ~/.bash_profile ] && echo "✓ exists" || echo "✗ missing")


    7. Current Shell:

    SHELL=$SHELL


    Status: Configuration complete!

    EOF


    cat config_test.txt

    ```


    **Congratulations!** You''ve mastered shell configuration!


    **You learned:**

    - Understanding shell configuration files (.bashrc, .bash_profile)

    - Customizing your shell prompt and settings

    - Creating and managing aliases for efficiency

    - Modifying PATH to include custom directories

    - Setting persistent environment variables

    - Integrating .bash_profile and .bashrc properly

    - Testing and verifying your configuration


    **Pro tips:**

    - Keep .bashrc organized with comments and sections

    - Backup your config files before making changes

    - Test changes with ''source ~/.bashrc'' before logging out

    - Share useful aliases with your team

    - Document complex configurations


    Your shell is now customized and ready for productive work!

    '
  hint: 'Use ''source ~/.bashrc'' to test changes without opening a new shell.

    The ''type'' command shows whether something is an alias, function, or binary.

    '
  validation:
    type: file-exists
    path: ~/shell_config/config_test.txt
    matcher: exists
  title: '**Testing Your Configuration**'
completion:
  message: Congratulations! You've completed this intermediate mission.
  xp: 300
  unlocks: []
