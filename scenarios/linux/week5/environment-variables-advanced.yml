mission:
  id: "linux/week5/environment-variables-advanced"
  title: "Mastering Environment Variables and Shell Configuration"
  difficulty: advanced
  description: "Deep dive into environment variables, shell startup files, and PATH manipulation"
  estimated_time: 60
  tags:
    - linux
    - environment
    - variables
    - bashrc
    - PATH
    - week5
    - cst8207

environment:
  image: "ubuntu:22.04"
  workdir: "/home/learner"
  setup:
    - "mkdir -p /home/learner/bin"
    - "mkdir -p /home/learner/scripts"
    - "mkdir -p /home/learner/.config"
    - "echo 'export CUSTOM_VAR=hello' > /home/learner/.bashrc"
    - "echo '#!/bin/bash' > /home/learner/bin/mytool"
    - "echo 'echo MyTool executed' >> /home/learner/bin/mytool"
    - "chmod +x /home/learner/bin/mytool"
    - "echo '#!/bin/bash' > /home/learner/scripts/deploy.sh"
    - "echo 'echo Deploying...' >> /home/learner/scripts/deploy.sh"
    - "chmod +x /home/learner/scripts/deploy.sh"

steps:
  - id: "understand-env-vars"
    title: "Examine Current Environment"
    description: |
      Environment variables are key-value pairs that affect how programs run.

      Common variables:
      - HOME: your home directory
      - USER: your username
      - PATH: directories searched for commands
      - SHELL: your current shell

      Display all environment variables:
      env | head -n 10

      Then display a specific variable:
      echo $HOME

      The $ prefix accesses a variable's value.
    hint: "Type: env | head -n 10 to see variables, then echo $HOME"
    validation:
      type: "command-output"
      command: "echo $HOME"
      matcher: "contains"
      expected: "/home/learner"

  - id: "create-session-variable"
    title: "Create Temporary Shell Variables"
    description: |
      Shell variables exist only in your current session.

      Create variables without 'export':
      PROJECT_NAME="TermGame"
      VERSION="1.0"
      echo "Working on $PROJECT_NAME v$VERSION"

      These variables only exist in your current shell.
      Child processes cannot see them.
    hint: "Create PROJECT_NAME and VERSION variables, then echo them"
    validation:
      type: "command-output"
      command: "PROJECT_NAME='TermGame' && echo $PROJECT_NAME"
      matcher: "exact"
      expected: "TermGame"

  - id: "export-environment-variable"
    title: "Export Variables to Child Processes"
    description: |
      Use 'export' to make variables available to child processes.

      Create and export a variable:
      export DATABASE_URL="postgresql://localhost/mydb"

      Exported variables are inherited by programs you run.

      Test it by running a subshell:
      bash -c 'echo $DATABASE_URL'

      Without export, the subshell wouldn't see it!
    hint: "Use: export DATABASE_URL='...' then test with bash -c"
    validation:
      type: "command-output"
      command: "export TEST_VAR='exported' && bash -c 'echo $TEST_VAR'"
      matcher: "exact"
      expected: "exported"

  - id: "understand-path"
    title: "Analyze the PATH Variable"
    description: |
      PATH determines where the shell looks for commands.

      Display your PATH:
      echo $PATH

      It's a colon-separated list of directories:
      /usr/local/bin:/usr/bin:/bin

      When you type a command, the shell searches these directories in order.

      Use 'which' to see where a command is located:
      which ls
      which bash
    hint: "Type: echo $PATH then which ls"
    validation:
      type: "command-output"
      command: "which ls"
      matcher: "contains"
      expected: "/bin/ls"

  - id: "add-to-path-session"
    title: "Add Directory to PATH (Session)"
    description: |
      Add your personal bin directory to PATH for this session.

      Prepend to PATH (search here first):
      export PATH="$HOME/bin:$PATH"

      The structure is:
      - $HOME/bin = your new directory
      - : = separator
      - $PATH = existing PATH

      Verify the change:
      echo $PATH

      Now you should be able to run 'mytool' directly!
    hint: "Type: export PATH='$HOME/bin:$PATH' then try: mytool"
    validation:
      type: "command-output"
      command: "export PATH='/home/learner/bin:$PATH' && which mytool"
      matcher: "contains"
      expected: "/home/learner/bin/mytool"

  - id: "test-custom-command"
    title: "Execute Custom Command from PATH"
    description: |
      With your bin directory in PATH, you can run scripts directly.

      Instead of:
      /home/learner/bin/mytool

      Just type:
      mytool

      The shell finds it automatically via PATH!

      Run mytool and observe the output.
    hint: "After adding bin to PATH, just type: mytool"
    validation:
      type: "command-output"
      command: "export PATH='/home/learner/bin:$PATH' && mytool"
      matcher: "contains"
      expected: "MyTool executed"

  - id: "modify-bashrc"
    title: "Make PATH Changes Permanent"
    description: |
      ~/.bashrc runs every time you start a new bash shell.

      Add PATH modification to .bashrc:
      echo 'export PATH="$HOME/bin:$HOME/scripts:$PATH"' >> ~/.bashrc

      This adds both bin/ and scripts/ to your PATH permanently.

      View your .bashrc:
      tail -n 5 ~/.bashrc

      The changes take effect in new shells, or run:
      source ~/.bashrc
    hint: "Add PATH export to .bashrc, then source it"
    validation:
      type: "command-output"
      command: "echo 'export PATH=\"$HOME/bin:$PATH\"' >> /tmp/test_bashrc && grep PATH /tmp/test_bashrc"
      matcher: "contains"
      expected: "export PATH"

  - id: "create-alias"
    title: "Create Command Aliases"
    description: |
      Aliases are shortcuts for frequently used commands.

      Create an alias in your current session:
      alias ll='ls -lah'
      alias gst='git status'
      alias ..='cd ..'

      Now 'll' runs 'ls -lah' automatically!

      Make aliases permanent by adding to ~/.bashrc:
      echo "alias ll='ls -lah'" >> ~/.bashrc

      Try using your new alias: ll
    hint: "Create alias ll='ls -lah' then use it"
    validation:
      type: "command-output"
      command: "alias ll='ls -lah' && ll /home 2>/dev/null | head -n 1"
      matcher: "contains"
      expected: "total"

  - id: "understand-quoting"
    title: "Master Variable Quoting Rules"
    description: |
      Quoting affects variable expansion differently:

      1. Double quotes ("") - variables expand:
         MSG="Hello"
         echo "Message: $MSG"  # Message: Hello

      2. Single quotes ('') - literal, no expansion:
         echo 'Message: $MSG'  # Message: $MSG

      3. No quotes - word splitting occurs:
         FILES="file1.txt file2.txt"
         echo $FILES   # Splits into separate words
         echo "$FILES" # Keeps as one string

      Test all three:
      VAR="World"
      echo "Hello $VAR"
      echo 'Hello $VAR'
      echo Hello $VAR
    hint: "Create VAR='World' and test echo with different quotes"
    validation:
      type: "command-output"
      command: "VAR='World' && echo \"Hello $VAR\""
      matcher: "exact"
      expected: "Hello World"

  - id: "special-variables"
    title: "Use Special Shell Variables"
    description: |
      Bash provides special built-in variables:

      - $? = exit status of last command (0 = success)
      - $$ = current process ID (PID)
      - $! = PID of last background process
      - $0 = name of the script/shell
      - $# = number of arguments
      - $@ = all arguments as separate words
      - $* = all arguments as single word

      Test exit status:
      ls /home >/dev/null 2>&1
      echo $?  # Should be 0 (success)

      ls /nonexistent >/dev/null 2>&1
      echo $?  # Should be non-zero (failure)

      Check your PID:
      echo $$
    hint: "Run: ls /home >/dev/null 2>&1 && echo $?"
    validation:
      type: "command-output"
      command: "ls /home >/dev/null 2>&1 && echo $?"
      matcher: "exact"
      expected: "0"

  - id: "complex-path-manipulation"
    title: "Advanced PATH Management"
    description: |
      Sometimes you need to clean up or reorganize PATH.

      Remove duplicates from PATH:
      PATH=$(echo "$PATH" | tr ':' '\n' | sort -u | tr '\n' ':' | sed 's/:$//')

      This:
      1. Splits PATH by : into lines
      2. Sorts and removes duplicates
      3. Joins back with :
      4. Removes trailing :

      Add multiple directories safely:
      for dir in ~/bin ~/.local/bin ~/scripts; do
        if [ -d "$dir" ] && [[ ":$PATH:" != *":$dir:"* ]]; then
          PATH="$dir:$PATH"
        fi
      done

      This only adds directories that exist and aren't already in PATH.
    hint: "Practice the PATH manipulation commands"
    validation:
      type: "command-output"
      command: "dir=~/bin && [[ -d $dir ]] && echo 'exists' || echo 'missing'"
      matcher: "contains"
      expected: "exists"

  - id: "configure-startup-files"
    title: "Understand Shell Startup File Hierarchy"
    description: |
      Bash loads different files depending on how it starts:

      Login shell (when you log in):
      1. /etc/profile (system-wide)
      2. ~/.bash_profile (or ~/.profile)
      3. ~/.bash_login
      4. ~/.bashrc (usually sourced from profile)

      Interactive non-login shell (new terminal window):
      - ~/.bashrc

      Best practice:
      - Put PATH and environment variables in ~/.bash_profile
      - Put aliases and functions in ~/.bashrc
      - Source ~/.bashrc from ~/.bash_profile:
        if [ -f ~/.bashrc ]; then . ~/.bashrc; fi

      Create a proper .bash_profile:
      cat > ~/.bash_profile << 'EOF'
      if [ -f ~/.bashrc ]; then
        source ~/.bashrc
      fi
      export PATH="$HOME/bin:$PATH"
      EOF
    hint: "Create or edit ~/.bash_profile with proper structure"
    validation:
      type: "command-output"
      command: "echo 'if [ -f ~/.bashrc ]; then source ~/.bashrc; fi' > /tmp/test_profile && grep bashrc /tmp/test_profile"
      matcher: "contains"
      expected: "bashrc"

  - id: "environment-best-practices"
    title: "Apply Environment Variable Best Practices"
    description: |
      Professional environment variable management:

      1. Naming: Use UPPERCASE for exported variables
         export DATABASE_URL="..."

      2. Defaults: Use parameter expansion for defaults
         echo ${PORT:-8080}  # Use 8080 if PORT unset

      3. Checking: Verify required variables
         if [ -z "$REQUIRED_VAR" ]; then
           echo "Error: REQUIRED_VAR not set"
           exit 1
         fi

      4. Configuration: Keep sensitive data in separate file
         if [ -f ~/.env ]; then source ~/.env; fi

      5. Documentation: Comment your .bashrc
         # Development environment
         export DEV_SERVER="localhost:3000"

      Create a well-structured environment setup:
      cat > ~/setup_env.sh << 'EOF'
      #!/bin/bash
      # Development environment setup

      export PROJECT_ROOT="$HOME/projects"
      export PATH="$PROJECT_ROOT/bin:$PATH"
      export EDITOR="${EDITOR:-vim}"

      # Only set if not already set
      if [ -z "$DATABASE_URL" ]; then
        export DATABASE_URL="postgresql://localhost/dev"
      fi

      echo "Environment configured for development"
      EOF

      chmod +x ~/setup_env.sh
      source ~/setup_env.sh
    hint: "Create the setup_env.sh script and source it"
    validation:
      type: "command-output"
      command: "EDITOR='vim' && echo ${EDITOR:-nano}"
      matcher: "exact"
      expected: "vim"

completion:
  message: |
    Outstanding work! You've mastered advanced environment configuration:

    ✓ Environment vs shell variables (export)
    ✓ PATH manipulation and custom commands
    ✓ Persistent configuration via .bashrc
    ✓ Aliases and shortcuts
    ✓ Quoting rules and variable expansion
    ✓ Special variables ($?, $$, $@)
    ✓ Shell startup file hierarchy
    ✓ Best practices for environment management

    These skills are essential for:
    - Customizing your development environment
    - Writing portable shell scripts
    - Managing application configuration
    - Debugging environment issues

    You can now set up professional-grade shell environments!
  xp: 500
  unlocks:
    - "linux/week5/bashrc-customization-expert"
    - "linux/week5/practice-environment-debugging"
