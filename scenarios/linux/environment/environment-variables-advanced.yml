mission:
  id: linux/environment/environment-variables-advanced
  title: Mastering Environment Variables and Shell Configuration
  difficulty: advanced
  description: Deep dive into environment variables, shell startup files, and PATH
    manipulation
  estimated_time: 60
  tags:
  - linux
  - environment
  - variables
  - bashrc
  - PATH
environment:
  image: ubuntu:22.04
  workdir: /home/learner
  setup:
  - mkdir -p /home/learner/bin
  - mkdir -p /home/learner/scripts
  - mkdir -p /home/learner/.config
  - echo 'export CUSTOM_VAR=hello' > /home/learner/.bashrc
  - echo '#!/bin/bash' > /home/learner/bin/mytool
  - echo 'echo MyTool executed' >> /home/learner/bin/mytool
  - chmod +x /home/learner/bin/mytool
  - echo '#!/bin/bash' > /home/learner/scripts/deploy.sh
  - echo 'echo Deploying...' >> /home/learner/scripts/deploy.sh
  - chmod +x /home/learner/scripts/deploy.sh
steps:
- id: understand-env-vars
  title: Examine Current Environment
  description: 'Environment variables are key-value pairs that affect how programs
    run.


    Common variables:

    - HOME: your home directory

    - USER: your username

    - PATH: directories searched for commands

    - SHELL: your current shell


    Display all environment variables:

    env | head -n 10


    Then display a specific variable:

    echo $HOME


    The $ prefix accesses a variable''s value.

    '
  hint: 'Type: env | head -n 10 to see variables, then echo $HOME'
  validation:
    type: command-output
    command: echo $HOME
    matcher: contains
    expected: /home/learner
- id: create-session-variable
  title: Create Temporary Shell Variables
  description: 'Shell variables exist only in your current session.


    Create variables without ''export'':

    PROJECT_NAME="TermGame"

    VERSION="1.0"

    echo "Working on $PROJECT_NAME v$VERSION"


    These variables only exist in your current shell.

    Child processes cannot see them.

    '
  hint: Create PROJECT_NAME and VERSION variables, then echo them
  validation:
    type: command-output
    command: PROJECT_NAME='TermGame' && echo $PROJECT_NAME
    matcher: exact
    expected: TermGame
- id: export-environment-variable
  title: Export Variables to Child Processes
  description: 'Use ''export'' to make variables available to child processes.


    Create and export a variable:

    export DATABASE_URL="postgresql://localhost/mydb"


    Exported variables are inherited by programs you run.


    Test it by running a subshell:

    bash -c ''echo $DATABASE_URL''


    Without export, the subshell wouldn''t see it!

    '
  hint: 'Use: export DATABASE_URL=''...'' then test with bash -c'
  validation:
    type: command-output
    command: export TEST_VAR='exported' && bash -c 'echo $TEST_VAR'
    matcher: exact
    expected: exported
- id: understand-path
  title: Analyze the PATH Variable
  description: 'PATH determines where the shell looks for commands.


    Display your PATH:

    echo $PATH


    It''s a colon-separated list of directories:

    /usr/local/bin:/usr/bin:/bin


    When you type a command, the shell searches these directories in order.


    Use ''which'' to see where a command is located:

    which ls

    which bash

    '
  hint: 'Type: echo $PATH then which ls'
  validation:
    type: command-output
    command: which ls
    matcher: contains
    expected: /bin/ls
- id: add-to-path-session
  title: Add Directory to PATH (Session)
  description: 'Add your personal bin directory to PATH for this session.


    Prepend to PATH (search here first):

    export PATH="$HOME/bin:$PATH"


    The structure is:

    - $HOME/bin = your new directory

    - : = separator

    - $PATH = existing PATH


    Verify the change:

    echo $PATH


    Now you should be able to run ''mytool'' directly!

    '
  hint: 'Type: export PATH=''$HOME/bin:$PATH'' then try: mytool'
  validation:
    type: command-output
    command: export PATH='/home/learner/bin:$PATH' && which mytool
    matcher: contains
    expected: /home/learner/bin/mytool
- id: test-custom-command
  title: Execute Custom Command from PATH
  description: 'With your bin directory in PATH, you can run scripts directly.


    Instead of:

    /home/learner/bin/mytool


    Just type:

    mytool


    The shell finds it automatically via PATH!


    Run mytool and observe the output.

    '
  hint: 'After adding bin to PATH, just type: mytool'
  validation:
    type: command-output
    command: export PATH='/home/learner/bin:$PATH' && mytool
    matcher: contains
    expected: MyTool executed
- id: modify-bashrc
  title: Make PATH Changes Permanent
  description: '~/.bashrc runs every time you start a new bash shell.


    Add PATH modification to .bashrc:

    echo ''export PATH="$HOME/bin:$HOME/scripts:$PATH"'' >> ~/.bashrc


    This adds both bin/ and scripts/ to your PATH permanently.


    View your .bashrc:

    tail -n 5 ~/.bashrc


    The changes take effect in new shells, or run:

    source ~/.bashrc

    '
  hint: Add PATH export to .bashrc, then source it
  validation:
    type: command-output
    command: echo 'export PATH="$HOME/bin:$PATH"' >> /tmp/test_bashrc && grep PATH
      /tmp/test_bashrc
    matcher: contains
    expected: export PATH
- id: create-alias
  title: Create Command Aliases
  description: 'Aliases are shortcuts for frequently used commands.


    Create an alias in your current session:

    alias ll=''ls -lah''

    alias gst=''git status''

    alias ..=''cd ..''


    Now ''ll'' runs ''ls -lah'' automatically!


    Make aliases permanent by adding to ~/.bashrc:

    echo "alias ll=''ls -lah''" >> ~/.bashrc


    Try using your new alias: ll

    '
  hint: Create alias ll='ls -lah' then use it
  validation:
    type: command-output
    command: alias ll='ls -lah' && ll /home 2>/dev/null | head -n 1
    matcher: contains
    expected: total
- id: understand-quoting
  title: Master Variable Quoting Rules
  description: "Quoting affects variable expansion differently:\n\n1. Double quotes\
    \ (\"\") - variables expand:\n   MSG=\"Hello\"\n   echo \"Message: $MSG\"  # Message:\
    \ Hello\n\n2. Single quotes ('') - literal, no expansion:\n   echo 'Message: $MSG'\
    \  # Message: $MSG\n\n3. No quotes - word splitting occurs:\n   FILES=\"file1.txt\
    \ file2.txt\"\n   echo $FILES   # Splits into separate words\n   echo \"$FILES\"\
    \ # Keeps as one string\n\nTest all three:\nVAR=\"World\"\necho \"Hello $VAR\"\
    \necho 'Hello $VAR'\necho Hello $VAR\n"
  hint: Create VAR='World' and test echo with different quotes
  validation:
    type: command-output
    command: VAR='World' && echo "Hello $VAR"
    matcher: exact
    expected: Hello World
- id: special-variables
  title: Use Special Shell Variables
  description: 'Bash provides special built-in variables:


    - $? = exit status of last command (0 = success)

    - $$ = current process ID (PID)

    - $! = PID of last background process

    - $0 = name of the script/shell

    - $# = number of arguments

    - $@ = all arguments as separate words

    - $* = all arguments as single word


    Test exit status:

    ls /home >/dev/null 2>&1

    echo $?  # Should be 0 (success)


    ls /nonexistent >/dev/null 2>&1

    echo $?  # Should be non-zero (failure)


    Check your PID:

    echo $$

    '
  hint: 'Run: ls /home >/dev/null 2>&1 && echo $?'
  validation:
    type: command-output
    command: ls /home >/dev/null 2>&1 && echo $?
    matcher: exact
    expected: '0'
- id: complex-path-manipulation
  title: Advanced PATH Management
  description: "Sometimes you need to clean up or reorganize PATH.\n\nRemove duplicates\
    \ from PATH:\nPATH=$(echo \"$PATH\" | tr ':' '\\n' | sort -u | tr '\\n' ':' |\
    \ sed 's/:$//')\n\nThis:\n1. Splits PATH by : into lines\n2. Sorts and removes\
    \ duplicates\n3. Joins back with :\n4. Removes trailing :\n\nAdd multiple directories\
    \ safely:\nfor dir in ~/bin ~/.local/bin ~/scripts; do\n  if [ -d \"$dir\" ] &&\
    \ [[ \":$PATH:\" != *\":$dir:\"* ]]; then\n    PATH=\"$dir:$PATH\"\n  fi\ndone\n\
    \nThis only adds directories that exist and aren't already in PATH.\n"
  hint: Practice the PATH manipulation commands
  validation:
    type: command-output
    command: dir=~/bin && [[ -d $dir ]] && echo 'exists' || echo 'missing'
    matcher: contains
    expected: exists
- id: configure-startup-files
  title: Understand Shell Startup File Hierarchy
  description: "Bash loads different files depending on how it starts:\n\nLogin shell\
    \ (when you log in):\n1. /etc/profile (system-wide)\n2. ~/.bash_profile (or ~/.profile)\n\
    3. ~/.bash_login\n4. ~/.bashrc (usually sourced from profile)\n\nInteractive non-login\
    \ shell (new terminal window):\n- ~/.bashrc\n\nBest practice:\n- Put PATH and\
    \ environment variables in ~/.bash_profile\n- Put aliases and functions in ~/.bashrc\n\
    - Source ~/.bashrc from ~/.bash_profile:\n  if [ -f ~/.bashrc ]; then . ~/.bashrc;\
    \ fi\n\nCreate a proper .bash_profile:\ncat > ~/.bash_profile << 'EOF'\nif [ -f\
    \ ~/.bashrc ]; then\n  source ~/.bashrc\nfi\nexport PATH=\"$HOME/bin:$PATH\"\n\
    EOF\n"
  hint: Create or edit ~/.bash_profile with proper structure
  validation:
    type: command-output
    command: echo 'if [ -f ~/.bashrc ]; then source ~/.bashrc; fi' > /tmp/test_profile
      && grep bashrc /tmp/test_profile
    matcher: contains
    expected: bashrc
- id: environment-best-practices
  title: Apply Environment Variable Best Practices
  description: "Professional environment variable management:\n\n1. Naming: Use UPPERCASE\
    \ for exported variables\n   export DATABASE_URL=\"...\"\n\n2. Defaults: Use parameter\
    \ expansion for defaults\n   echo ${PORT:-8080}  # Use 8080 if PORT unset\n\n\
    3. Checking: Verify required variables\n   if [ -z \"$REQUIRED_VAR\" ]; then\n\
    \     echo \"Error: REQUIRED_VAR not set\"\n     exit 1\n   fi\n\n4. Configuration:\
    \ Keep sensitive data in separate file\n   if [ -f ~/.env ]; then source ~/.env;\
    \ fi\n\n5. Documentation: Comment your .bashrc\n   # Development environment\n\
    \   export DEV_SERVER=\"localhost:3000\"\n\nCreate a well-structured environment\
    \ setup:\ncat > ~/setup_env.sh << 'EOF'\n#!/bin/bash\n# Development environment\
    \ setup\n\nexport PROJECT_ROOT=\"$HOME/projects\"\nexport PATH=\"$PROJECT_ROOT/bin:$PATH\"\
    \nexport EDITOR=\"${EDITOR:-vim}\"\n\n# Only set if not already set\nif [ -z \"\
    $DATABASE_URL\" ]; then\n  export DATABASE_URL=\"postgresql://localhost/dev\"\n\
    fi\n\necho \"Environment configured for development\"\nEOF\n\nchmod +x ~/setup_env.sh\n\
    source ~/setup_env.sh\n"
  hint: Create the setup_env.sh script and source it
  validation:
    type: command-output
    command: EDITOR='vim' && echo ${EDITOR:-nano}
    matcher: exact
    expected: vim
completion:
  message: 'Outstanding work! You''ve mastered advanced environment configuration:


    ✓ Environment vs shell variables (export)

    ✓ PATH manipulation and custom commands

    ✓ Persistent configuration via .bashrc

    ✓ Aliases and shortcuts

    ✓ Quoting rules and variable expansion

    ✓ Special variables ($?, $$, $@)

    ✓ Shell startup file hierarchy

    ✓ Best practices for environment management


    These skills are essential for:

    - Customizing your development environment

    - Writing portable shell scripts

    - Managing application configuration

    - Debugging environment issues


    You can now set up professional-grade shell environments!

    '
  xp: 500
  unlocks:
  - linux/week5/bashrc-customization-expert
  - linux/week5/practice-environment-debugging
