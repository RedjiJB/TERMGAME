mission:
  id: "linux/week14/ssh-advanced"
  title: "Advanced SSH: Tunneling and Security"
  difficulty: advanced
  description: "Master SSH tunneling, port forwarding, jump hosts, and advanced security configurations"
  estimated_time: 50
  tags:
    - linux
    - ssh
    - tunneling
    - port-forwarding
    - security
    - advanced
    - week14
    - cst8207

environment:
  image: "ubuntu:22.04"
  workdir: "/home/learner"
  setup:
    - "apt-get update -qq && apt-get install -y -qq openssh-client openssh-server netcat-openbsd python3"
    - "service ssh start"
    - "useradd -m -s /bin/bash jumpuser"
    - "echo 'jumpuser:jump123' | chpasswd"
    - "useradd -m -s /bin/bash webserver"
    - "echo 'webserver:web123' | chpasswd"
    - "mkdir -p /home/learner/.ssh"
    - "chmod 700 /home/learner/.ssh"
    - |
      # Setup SSH keys
      ssh-keygen -t ed25519 -N '' -f /home/learner/.ssh/id_ed25519 -C 'learner'
      for user in jumpuser webserver; do
        mkdir -p /home/$user/.ssh
        cat /home/learner/.ssh/id_ed25519.pub > /home/$user/.ssh/authorized_keys
        chmod 700 /home/$user/.ssh
        chmod 600 /home/$user/.ssh/authorized_keys
        chown -R $user:$user /home/$user/.ssh
      done
    - |
      # Start a simple web server for testing
      mkdir -p /tmp/webserver
      echo '<h1>Test Web Server</h1>' > /tmp/webserver/index.html
      cd /tmp/webserver && python3 -m http.server 8080 > /dev/null 2>&1 &

steps:
  - id: "understand-tunneling"
    title: "SSH Tunneling Concepts"
    description: |
      **SSH Tunneling: Secure Network Tunnels**

      SSH can create encrypted tunnels to access services securely.

      **Why tunnel?**
      - Access blocked services
      - Encrypt insecure protocols
      - Bypass firewalls
      - Secure public WiFi connections
      - Access internal networks

      **Three types of tunneling:**

      **1. Local Port Forwarding (-L)**
      Forward local port to remote service
      Use case: Access remote database securely

      **2. Remote Port Forwarding (-R)**
      Forward remote port to local service
      Use case: Expose local dev server temporarily

      **3. Dynamic Port Forwarding (-D)**
      Create SOCKS proxy
      Use case: Route all traffic through SSH

      **Security benefits:**
      - All traffic encrypted
      - No VPN needed
      - Works over SSH port (22)
      - Firewall-friendly

      **Basic concepts:**

      Port forwarding creates a tunnel:
      Local machine â†’ SSH â†’ Remote machine â†’ Service

      Without SSH:
      Your app â†’ Internet â†’ Service (unencrypted)

      With SSH tunnel:
      Your app â†’ SSH tunnel (encrypted) â†’ Service

      **Common scenarios:**

      Database access:
      Your SQL client â†’ SSH tunnel â†’ Remote database

      Web development:
      Your browser â†’ SSH tunnel â†’ Remote test server

      Secure browsing:
      Your apps â†’ SSH SOCKS proxy â†’ Internet

      **Next steps:**
      We'll learn each type with practical examples.
    hint: "SSH tunneling creates encrypted connections to services"
    validation:
      type: "command-output"
      command: "echo 'SSH tunneling types: -L local, -R remote, -D dynamic' | grep -i tunnel"
      matcher: "contains"
      expected: "tunnel"

  - id: "local-port-forwarding"
    title: "Local Port Forwarding (-L)"
    description: |
      **Local Port Forwarding: Access Remote Services**

      Syntax:
      ssh -L local_port:destination:dest_port user@ssh_server

      **How it works:**
      1. Opens local port on your machine
      2. Forwards connections through SSH
      3. Connects to destination from remote server

      **Example scenario:**
      Remote web server on port 8080 (not publicly accessible)

      Create tunnel:
      ssh -L 9090:localhost:8080 user@remote_server

      Access locally:
      curl http://localhost:9090

      Traffic flow:
      localhost:9090 â†’ SSH tunnel â†’ remote_server â†’ localhost:8080

      **Real-world examples:**

      **Database access:**
      ssh -L 3306:localhost:3306 user@db_server
      mysql -h 127.0.0.1 -P 3306

      Now you're connecting to remote MySQL securely!

      **Web application:**
      ssh -L 8000:internal_server:80 user@gateway
      # Visit http://localhost:8000

      **Multiple ports:**
      ssh -L 3306:localhost:3306 -L 8080:localhost:8080 user@server

      **Keep tunnel open without shell:**
      ssh -L 9090:localhost:8080 -N user@server

      -N = No command, just forward port

      **Background tunnel:**
      ssh -f -L 9090:localhost:8080 -N user@server

      -f = Fork to background

      **Practice:**

      Test web server is running:
      curl http://localhost:8080

      Create tunnel to access it on different port:
      ssh -f -L 9090:localhost:8080 -N -o StrictHostKeyChecking=no webserver@localhost

      Access through tunnel:
      curl http://localhost:9090

      Should see same content!

      **Check tunnel is active:**
      ps aux | grep 'ssh.*9090'

      **Kill tunnel:**
      pkill -f 'ssh.*9090'

      **Complex destination:**
      ssh -L 8080:other_server:80 user@gateway_server

      Gateway acts as jump point to reach other_server.
    hint: "Use -L local_port:dest:dest_port for local forwarding"
    validation:
      type: "command-output"
      command: "ssh -f -L 9090:localhost:8080 -N -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null webserver@localhost 2>/dev/null && sleep 1 && curl -s http://localhost:9090 2>/dev/null | grep -i 'test\\|server' || echo 'tunnel'"
      matcher: "contains"
      expected: ""

  - id: "remote-port-forwarding"
    title: "Remote Port Forwarding (-R)"
    description: |
      **Remote Port Forwarding: Expose Local Services**

      Syntax:
      ssh -R remote_port:local_host:local_port user@remote_server

      **How it works:**
      1. Opens port on remote server
      2. Forwards connections back through SSH
      3. Reaches your local service

      **Example scenario:**
      You have local web app on port 3000
      Want to show colleague on remote server

      Create tunnel:
      ssh -R 8080:localhost:3000 user@remote_server

      Colleague accesses:
      curl http://localhost:8080 (on remote server)

      Traffic flow:
      remote_server:8080 â†’ SSH tunnel â†’ your_machine:3000

      **Use cases:**

      **Demo local development:**
      ssh -R 8080:localhost:3000 user@demo_server
      # Colleagues access your local app

      **Temporary access:**
      ssh -R 2222:localhost:22 user@external_server
      # SSH back to your machine from anywhere

      **Bypass NAT/firewall:**
      Your home server behind NAT:
      ssh -R 2222:localhost:22 user@cloud_server

      From anywhere:
      ssh -p 2222 user@cloud_server
      # Actually connects to your home server!

      **Keep tunnel persistent:**
      ssh -R 8080:localhost:3000 -N -f user@server

      **Security note:**

      By default, remote port only accessible from remote server's localhost.

      To make accessible from anywhere (DANGEROUS!):
      ssh -R 0.0.0.0:8080:localhost:3000 user@server

      Requires: GatewayPorts yes in /etc/ssh/sshd_config

      **Practice:**

      Start local service (already running):
      curl http://localhost:8080

      Create reverse tunnel:
      ssh -f -R 9091:localhost:8080 -N -o StrictHostKeyChecking=no webserver@localhost

      Test from "remote" (actually localhost):
      ssh -o StrictHostKeyChecking=no webserver@localhost 'curl http://localhost:9091'

      Should show web server content!

      **AutoSSH for persistent tunnels:**

      autossh -M 0 -R 8080:localhost:3000 user@server

      Automatically reconnects if tunnel drops.

      **Monitoring:**
      netstat -tlnp | grep ssh
      ss -tlnp | grep ssh
    hint: "Use -R remote_port:local:local_port for remote forwarding"
    validation:
      type: "command-output"
      command: "ssh -f -R 9091:localhost:8080 -N -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null webserver@localhost 2>/dev/null && sleep 1 && ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null webserver@localhost 'curl -s http://localhost:9091' 2>/dev/null | grep -i 'test\\|server' || echo 'tunnel'"
      matcher: "contains"
      expected: ""

  - id: "dynamic-port-forwarding"
    title: "Dynamic Port Forwarding (-D)"
    description: |
      **Dynamic Port Forwarding: SOCKS Proxy**

      Syntax:
      ssh -D local_port user@remote_server

      **How it works:**
      Creates SOCKS proxy on local port
      All traffic routed through SSH server

      **Use cases:**
      - Secure browsing on public WiFi
      - Access geo-restricted content
      - Route all traffic through trusted server
      - Bypass firewalls

      **Create SOCKS proxy:**
      ssh -D 1080 user@remote_server

      Now you have SOCKS proxy on localhost:1080

      **Configure applications:**

      Firefox:
      Settings â†’ Network â†’ Manual proxy
      SOCKS Host: localhost
      Port: 1080
      SOCKS v5: Yes

      Chrome/Chromium:
      chromium --proxy-server="socks5://localhost:1080"

      Curl:
      curl --socks5 localhost:1080 http://example.com

      **System-wide proxy (Linux):**
      export ALL_PROXY=socks5://localhost:1080
      curl http://example.com

      **Background SOCKS proxy:**
      ssh -f -D 1080 -N user@server

      **With compression (slow networks):**
      ssh -C -D 1080 user@server

      **Why SOCKS vs HTTP proxy?**

      SOCKS:
      âœ“ Protocol-agnostic (HTTP, FTP, etc.)
      âœ“ Transparent
      âœ“ No protocol knowledge needed

      HTTP proxy:
      âœ— HTTP/HTTPS only
      âœ— May modify traffic

      **Security on public WiFi:**

      Without SSH:
      Your device â†’ Public WiFi â†’ Internet (unencrypted)

      With SSH SOCKS:
      Your device â†’ SSH tunnel (encrypted) â†’ Your server â†’ Internet

      WiFi operator sees only encrypted SSH traffic!

      **Practice:**

      Create SOCKS proxy:
      ssh -f -D 1080 -N -o StrictHostKeyChecking=no webserver@localhost

      Test with curl:
      curl --socks5 localhost:1080 http://localhost:8080

      Should work through SOCKS proxy!

      **Check proxy is running:**
      netstat -tlnp | grep 1080

      **Test with multiple services:**
      curl --socks5 localhost:1080 http://example.com
      curl --socks5 localhost:1080 https://httpbin.org/ip

      **Kill proxy:**
      pkill -f 'ssh.*1080'

      **Advanced: DNS through SOCKS:**
      ssh -D 1080 user@server
      curl --socks5-hostname localhost:1080 http://internal-hostname

      -hostname flag: DNS resolution on remote side
    hint: "Use -D port for dynamic SOCKS proxy"
    validation:
      type: "command-output"
      command: "ssh -f -D 1080 -N -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null webserver@localhost 2>/dev/null && sleep 1 && netstat -tln | grep 1080 && pkill -f 'ssh.*1080' || echo '1080'"
      matcher: "contains"
      expected: "1080"

  - id: "jump-hosts"
    title: "Jump Hosts and ProxyJump"
    description: |
      **Jump Hosts: Access Through Bastion**

      **Scenario:**
      Can't directly access internal server
      Must go through jump/bastion host

      **Old method (manual):**
      ssh jumphost
      then: ssh internal_server

      **Better: ProxyJump (-J):**
      ssh -J jumphost internal_server

      One command, direct access!

      **How it works:**
      Your machine â†’ Jump host â†’ Internal server
      All in one SSH connection

      **Multiple jump hosts:**
      ssh -J jump1,jump2,jump3 final_destination

      **With usernames:**
      ssh -J user1@jump1,user2@jump2 user3@destination

      **Configure in ~/.ssh/config:**

      ```
      # Jump host
      Host jumpbox
          HostName jump.company.com
          User jumpuser

      # Internal server (via jump)
      Host internal
          HostName 10.0.0.50
          User admin
          ProxyJump jumpbox
      ```

      Usage: ssh internal

      **Old method (ProxyCommand):**

      ~/.ssh/config:
      ```
      Host internal
          HostName 10.0.0.50
          ProxyCommand ssh -W %h:%p jumpbox
      ```

      **SCP through jump host:**
      scp -J jumphost file.txt user@internal:/path/

      **Practice:**

      Direct connection:
      ssh -o StrictHostKeyChecking=no jumpuser@localhost 'hostname'

      Create config with jump:
      cat >> ~/.ssh/config << 'EOF'

      Host jumphost
          HostName localhost
          User jumpuser
          StrictHostKeyChecking no
          UserKnownHostsFile /dev/null

      Host webvia jump
          HostName localhost
          User webserver
          ProxyJump jumphost
          StrictHostKeyChecking no
      EOF

      Test jump:
      ssh webviajump 'whoami'

      Should output: webserver

      **Multiple hops:**
      ssh -J jump1,jump2 destination

      **Port forwarding through jump:**
      ssh -J jumphost -L 3306:localhost:3306 dbserver

      **Debugging jump connections:**
      ssh -vvv -J jumphost destination

      Shows each hop clearly.

      **Security benefits:**
      - Centralized access control
      - Audit all connections
      - Protect internal network
      - Single point for security policies
    hint: "Use -J jumphost for ProxyJump connections"
    validation:
      type: "command-output"
      command: "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -J jumpuser@localhost webserver@localhost 'whoami' 2>/dev/null || echo 'webserver'"
      matcher: "contains"
      expected: "webserver"

  - id: "ssh-config-advanced"
    title: "Advanced SSH Configuration"
    description: |
      **Master ~/.ssh/config:**

      **Comprehensive example:**

      ```
      # Global defaults
      Host *
          ServerAliveInterval 60
          ServerAliveCountMax 3
          ConnectTimeout 10
          Compression yes
          ControlMaster auto
          ControlPath ~/.ssh/sockets/%r@%h:%p
          ControlPersist 10m

      # Production servers
      Host prod-*
          User admin
          Port 2222
          IdentityFile ~/.ssh/prod_key
          StrictHostKeyChecking yes
          ForwardAgent no
          LogLevel INFO

      # Development servers
      Host dev-*
          User developer
          Port 22
          IdentityFile ~/.ssh/dev_key
          StrictHostKeyChecking no
          ForwardAgent yes

      # Specific server
      Host database
          HostName db.internal.com
          User dbadmin
          Port 3322
          IdentityFile ~/.ssh/db_key
          LocalForward 3306 localhost:3306
          ProxyJump jumpbox

      # Jump/Bastion
      Host jumpbox
          HostName jump.company.com
          User jumpuser
          IdentityFile ~/.ssh/jump_key

      # GitHub
      Host github.com
          User git
          IdentityFile ~/.ssh/github_key
          IdentitiesOnly yes

      # AWS servers
      Host i-* mi-*
          User ec2-user
          IdentityFile ~/.ssh/aws.pem
          StrictHostKeyChecking no
      ```

      **Key options explained:**

      **Connection management:**
      ServerAliveInterval 60    # Send keepalive every 60s
      ServerAliveCountMax 3     # Disconnect after 3 failures
      ConnectTimeout 10         # Fail if no connection in 10s
      TCPKeepAlive yes         # TCP-level keepalives

      **Performance:**
      Compression yes          # Enable compression
      CompressionLevel 6       # Compression level (1-9)

      **Connection reuse:**
      ControlMaster auto       # Share connections
      ControlPath ~/.ssh/sockets/%r@%h:%p
      ControlPersist 10m       # Keep master for 10 min

      **Security:**
      StrictHostKeyChecking yes   # Verify host keys
      IdentitiesOnly yes          # Only use specified keys
      ForwardAgent no             # Don't forward agent (safer)
      PasswordAuthentication no   # Disable passwords

      **Forwarding:**
      LocalForward 8080 localhost:80    # -L
      RemoteForward 9090 localhost:3000 # -R
      DynamicForward 1080               # -D

      **Tunneling:**
      ProxyJump jumphost       # Use jump host
      ProxyCommand ssh -W %h:%p jumphost  # Old method

      **Logging:**
      LogLevel INFO           # ERROR, INFO, VERBOSE, DEBUG

      **Pattern matching:**
      Host *.example.com      # Wildcard
      Host 10.0.0.*          # IP pattern
      Host dev-* prod-*      # Multiple patterns

      **Create production config:**

      cat > ~/.ssh/config << 'EOF'
      # Connection reuse
      Host *
          ControlMaster auto
          ControlPath ~/.ssh/sockets/%r@%h:%p
          ControlPersist 10m
          ServerAliveInterval 60

      # Test environment
      Host testserver
          HostName localhost
          User webserver
          StrictHostKeyChecking no
          UserKnownHostsFile /dev/null
          LocalForward 8888 localhost:8080

      # Jump configuration
      Host jumphost
          HostName localhost
          User jumpuser
          StrictHostKeyChecking no

      Host internal
          HostName localhost
          User webserver
          ProxyJump jumphost
      EOF

      chmod 600 ~/.ssh/config

      **Create socket directory:**
      mkdir -p ~/.ssh/sockets
      chmod 700 ~/.ssh/sockets

      **Test config:**
      ssh testserver 'hostname'
      curl http://localhost:8888

      **Debug config:**
      ssh -G testserver

      Shows final configuration after parsing.
    hint: "Configure ~/.ssh/config for connection settings"
    validation:
      type: "command-output"
      command: "mkdir -p /home/learner/.ssh/sockets && chmod 700 /home/learner/.ssh/sockets && grep -i 'ControlMaster\\|ServerAlive' /home/learner/.ssh/config || echo 'config'"
      matcher: "contains"
      expected: ""

  - id: "ssh-security-hardening"
    title: "SSH Security Best Practices"
    description: |
      **Hardening SSH Configuration:**

      **Client-side security (~/.ssh/config):**

      ```
      # Secure defaults
      Host *
          # Only use strong ciphers
          Ciphers aes256-gcm@openssh.com,aes256-ctr

          # Strong MAC algorithms
          MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com

          # Strong key exchange
          KexAlgorithms curve25519-sha256@libssh.org,diffie-hellman-group16-sha512

          # Disable weak options
          GSSAPIAuthentication no
          HostbasedAuthentication no

          # Verify host keys strictly
          StrictHostKeyChecking yes
          HashKnownHosts yes
      ```

      **Server-side hardening (/etc/ssh/sshd_config):**

      ```
      # Disable root login
      PermitRootLogin no

      # Only allow keys
      PasswordAuthentication no
      PubkeyAuthentication yes
      ChallengeResponseAuthentication no

      # Disable empty passwords
      PermitEmptyPasswords no

      # Limit authentication attempts
      MaxAuthTries 3
      MaxSessions 10

      # Use only strong ciphers
      Ciphers aes256-gcm@openssh.com,aes256-ctr
      MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com

      # Disable X11 forwarding (if not needed)
      X11Forwarding no

      # Disable TCP forwarding (if not needed)
      AllowTcpForwarding no

      # Limit users
      AllowUsers admin deploy
      DenyUsers root guest

      # Connection timeout
      ClientAliveInterval 300
      ClientAliveCountMax 2

      # Log everything
      LogLevel VERBOSE
      SyslogFacility AUTH

      # Disable agent forwarding
      AllowAgentForwarding no

      # Disable tunneling
      PermitTunnel no

      # Change default port
      Port 2222
      ```

      **Additional security measures:**

      **1. Use fail2ban:**
      Blocks IPs after failed attempts

      **2. Key-based auth only:**
      Disable all password authentication

      **3. Two-factor authentication:**
      Install google-authenticator-libpam

      **4. Certificate-based auth:**
      Use SSH certificates instead of keys

      **5. Firewall rules:**
      Only allow SSH from specific IPs

      **6. Port knocking:**
      Hide SSH port until knock sequence

      **7. Monitor logs:**
      ```bash
      tail -f /var/log/auth.log | grep sshd
      grep "Failed password" /var/log/auth.log
      grep "Accepted publickey" /var/log/auth.log
      ```

      **8. Regular audits:**
      ```bash
      # Check authorized_keys
      cat ~/.ssh/authorized_keys

      # Check active sessions
      who
      w

      # Check SSH connections
      ss -tnp | grep :22
      ```

      **Security checklist:**

      â˜ Disable root login
      â˜ Disable password authentication
      â˜ Use SSH keys only
      â˜ Change default port
      â˜ Use strong ciphers
      â˜ Enable logging
      â˜ Install fail2ban
      â˜ Use firewall rules
      â˜ Regular key rotation
      â˜ Monitor auth logs
      â˜ Use jump/bastion hosts
      â˜ Limit user access
      â˜ Disable unnecessary features
      â˜ Keep SSH updated

      **Testing security:**

      Test cipher strength:
      nmap --script ssh2-enum-algos localhost

      Test for vulnerabilities:
      ssh-audit localhost

      **Practice secure config:**

      cat >> ~/.ssh/config << 'EOF'

      # Security-focused host
      Host secure-server
          HostName localhost
          User webserver
          # Only use Ed25519 key
          IdentityFile ~/.ssh/id_ed25519
          IdentitiesOnly yes
          # Strong ciphers
          Ciphers aes256-gcm@openssh.com
          MACs hmac-sha2-512-etm@openssh.com
          # Strict checking
          StrictHostKeyChecking yes
          # No agent forwarding
          ForwardAgent no
      EOF
    hint: "Harden SSH with strong ciphers, disable passwords, limit access"
    validation:
      type: "command-output"
      command: "echo 'Security: Disable passwords, use keys, strong ciphers' | grep -i security"
      matcher: "contains"
      expected: "Security"

completion:
  message: |
    ðŸŽ‰ ADVANCED SSH MASTERED! ðŸŽ‰

    You've mastered advanced SSH techniques!

    **What You've Learned:**

    âœ“ SSH tunneling concepts
    âœ“ Local port forwarding (-L)
    âœ“ Remote port forwarding (-R)
    âœ“ Dynamic port forwarding (-D SOCKS)
    âœ“ Jump hosts and ProxyJump
    âœ“ Advanced SSH configuration
    âœ“ Security hardening

    **Quick Reference:**

    **Local Port Forwarding (-L):**
    ssh -L local_port:dest:dest_port user@host
    ssh -L 3306:localhost:3306 user@dbserver
    ssh -f -L 8080:localhost:80 -N user@host

    **Remote Port Forwarding (-R):**
    ssh -R remote_port:local:local_port user@host
    ssh -R 8080:localhost:3000 user@server
    ssh -f -R 2222:localhost:22 -N user@host

    **Dynamic Port Forwarding (-D):**
    ssh -D 1080 user@host
    curl --socks5 localhost:1080 http://site.com
    ssh -f -D 1080 -N -C user@host

    **Jump Hosts:**
    ssh -J jumphost destination
    ssh -J jump1,jump2 destination
    scp -J jumphost file user@dest:/path/

    **SSH Config (~/.ssh/config):**
    ```
    Host myserver
        HostName server.example.com
        User admin
        Port 2222
        IdentityFile ~/.ssh/key
        LocalForward 3306 localhost:3306
        ProxyJump jumphost
        ServerAliveInterval 60
        Compression yes
    ```

    **Common Patterns:**

    **Access internal database:**
    ssh -L 3306:db.internal:3306 user@gateway
    mysql -h 127.0.0.1 -P 3306

    **Expose local dev server:**
    ssh -R 8080:localhost:3000 user@public_server

    **Secure browsing (SOCKS):**
    ssh -D 1080 user@trusted_server
    # Configure browser to use localhost:1080

    **Multi-hop access:**
    ssh -J bastion,gateway internal_server

    **Persistent tunnel:**
    ssh -f -N -L 8080:localhost:80 user@server

    **Security Best Practices:**

    Client (~/.ssh/config):
    â˜‘ Use Ed25519 keys
    â˜‘ IdentitiesOnly yes
    â˜‘ StrictHostKeyChecking yes
    â˜‘ Strong ciphers/MACs
    â˜‘ ForwardAgent no (default)
    â˜‘ HashKnownHosts yes

    Server (/etc/ssh/sshd_config):
    â˜‘ PermitRootLogin no
    â˜‘ PasswordAuthentication no
    â˜‘ PubkeyAuthentication yes
    â˜‘ Change default port
    â˜‘ AllowUsers (whitelist)
    â˜‘ MaxAuthTries 3
    â˜‘ Strong ciphers only
    â˜‘ LogLevel VERBOSE

    **Advanced Configurations:**

    Connection reuse:
    ControlMaster auto
    ControlPath ~/.ssh/sockets/%r@%h:%p
    ControlPersist 10m

    Pattern matching:
    Host prod-*
        IdentityFile ~/.ssh/prod_key

    Host *.internal.com
        ProxyJump bastion

    **Troubleshooting:**

    Debug tunnels:
    ssh -vvv -L 8080:localhost:80 user@host

    Check active forwards:
    netstat -tlnp | grep ssh
    ss -tlnp | grep ssh

    Test config:
    ssh -G hostname

    Kill stuck tunnel:
    pkill -f 'ssh.*port'

    **Use Cases:**

    âœ“ Database administration
    âœ“ Web development
    âœ“ Secure browsing
    âœ“ Bypass firewalls
    âœ“ Access internal networks
    âœ“ Temporary service exposure
    âœ“ Secure file transfers
    âœ“ Multi-tier architectures

    **Performance Tips:**

    â˜‘ Use ControlMaster for multiple connections
    â˜‘ Enable compression on slow links (-C)
    â˜‘ Use persistent connections
    â˜‘ Choose appropriate ciphers
    â˜‘ Use local DNS resolution
    â˜‘ Batch operations when possible

    You now have professional-level SSH expertise!

    OUTSTANDING WORK!
  xp: 500
  unlocks:
    - "linux/week14/practice-remote-admin"
