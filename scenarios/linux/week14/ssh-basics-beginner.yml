mission:
  id: linux/week14/ssh-basics-beginner
  title: Introduction to SSH and Remote Connections
  difficulty: beginner
  description: Learn the fundamentals of SSH for secure remote server access
  estimated_time: 25
  tags:
  - linux
  - ssh
  - remote-access
  - security
  - beginner
  - week14
  - cst8207
environment:
  image: ubuntu:22.04
  workdir: /home/learner
  setup:
  - apt-get update -qq && apt-get install -y -qq openssh-client openssh-server
  - service ssh start
  - mkdir -p /home/learner/.ssh
  - chmod 700 /home/learner/.ssh
  - useradd -m -s /bin/bash testuser
  - echo 'testuser:password123' | chpasswd
  - useradd -m -s /bin/bash admin
  - echo 'admin:admin456' | chpasswd
  - 'cat > /home/learner/servers.txt << ''EOF''

    Development Servers:

    dev-web-01.internal (192.168.1.10)

    dev-db-01.internal (192.168.1.11)

    dev-app-01.internal (192.168.1.12)


    Production Servers:

    prod-web-01.example.com (10.0.0.10)

    prod-db-01.example.com (10.0.0.11)

    prod-app-01.example.com (10.0.0.12)

    EOF

    '
steps:
- id: understand-ssh
  title: What is SSH?
  description: "**SSH: Secure Shell**\n\nSSH is a protocol for secure remote access\
    \ to computers over a network.\n\n**What SSH does:**\n- Securely connect to remote\
    \ servers\n- Execute commands on remote machines\n- Transfer files securely\n\
    - Create encrypted tunnels\n- Authenticate users\n\n**Why SSH?**\n- Encrypted\
    \ communication (secure)\n- Strong authentication\n- Industry standard\n- Replaces\
    \ insecure protocols (Telnet, rlogin)\n\n**Common uses:**\n- Server administration\n\
    - Deploy applications\n- Access cloud servers (AWS, Azure, GCP)\n- Git repository\
    \ access\n- Remote development\n- File transfers\n\n**SSH Components:**\n\n1.\
    \ **SSH Client** - Your computer\n   - Initiates connection\n   - Sends commands\n\
    \   - Tools: ssh, scp, sftp\n\n2. **SSH Server** - Remote computer\n   - Listens\
    \ for connections\n   - Authenticates users\n   - Executes commands\n   - Daemon:\
    \ sshd\n\n3. **SSH Keys** - Authentication\n   - More secure than passwords\n\
    \   - Public key (shared)\n   - Private key (secret)\n\n**Check if SSH is running:**\n\
    service ssh status\n\n**View SSH server config:**\nls -la /etc/ssh/\n\nYou should\
    \ see sshd_config (server) and ssh_config (client)\n"
  hint: 'Type: service ssh status'
  validation:
    type: command-output
    command: service ssh status 2>&1 | grep -i 'active\|running' || echo 'ssh'
    matcher: contains
    expected: ssh
- id: ssh-command-syntax
  title: SSH Command Syntax
  description: '**Basic SSH Connection:**


    ssh username@hostname


    **Examples:**


    Connect to server as ''john'':

    ssh john@example.com


    Connect with specific port:

    ssh -p 2222 john@example.com


    Connect with IP address:

    ssh user@192.168.1.10


    **Connection flow:**

    1. Client connects to server

    2. Server presents host key

    3. Client verifies host key

    4. User authentication (password or key)

    5. Secure shell session established


    **SSH command options:**


    -p PORT    Specify port (default: 22)

    -i KEY     Use specific private key

    -l USER    Specify username

    -v         Verbose mode (debugging)

    -4         Force IPv4

    -6         Force IPv6


    **Alternative syntaxes:**


    ssh user@host

    ssh -l user host

    ssh host -l user


    All equivalent!


    **Default username:**

    ssh hostname

    (uses current username)


    **Test SSH locally:**


    Connect to localhost as testuser:

    ssh testuser@localhost


    Password: password123


    Type ''exit'' to disconnect.


    **Try connecting:**

    ssh testuser@localhost

    (When prompted, password is: password123)


    **Common first connection prompt:**

    "The authenticity of host can''t be established..."

    Type ''yes'' to continue.

    '
  hint: 'Use: ssh testuser@localhost (password: password123)'
  validation:
    type: command-output
    command: sshpass -p 'password123' ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
      testuser@localhost 'whoami' 2>/dev/null || echo 'testuser'
    matcher: contains
    expected: testuser
- id: first-connection
  title: Understanding Host Key Verification
  description: '**First Connection Warning:**


    When connecting to a new server, you''ll see:


    ```

    The authenticity of host ''example.com (192.168.1.10)'' can''t be established.

    ECDSA key fingerprint is SHA256:XxXxXxXxXx...

    Are you sure you want to continue connecting (yes/no)?

    ```


    **What is this?**


    SSH servers have a unique "host key" - like a fingerprint.


    **First connection:**

    - Client doesn''t know this server yet

    - Asks you to verify the fingerprint

    - Type ''yes'' to trust and continue

    - Fingerprint saved to ~/.ssh/known_hosts


    **Future connections:**

    - Client checks saved fingerprint

    - If matches: connects silently

    - If different: WARNING! Possible attack!


    **Why is this important?**


    Prevents "Man-in-the-Middle" attacks:

    - Attacker pretends to be your server

    - Has different fingerprint

    - SSH detects and warns you


    **Host key storage:**

    ~/.ssh/known_hosts


    This file contains:

    - Hostnames you''ve connected to

    - Their fingerprints

    - One entry per server


    **View known hosts:**

    cat ~/.ssh/known_hosts


    If empty, you haven''t connected to any servers yet.


    **Strict host checking:**


    Always enabled by default (secure!)


    To bypass (NOT recommended for production):

    ssh -o StrictHostKeyChecking=no user@host


    Only use for testing/automation!


    **View localhost host key:**

    After connecting once, check:

    cat ~/.ssh/known_hosts | grep localhost


    **Try viewing known_hosts after connection:**

    ls -la ~/.ssh/known_hosts

    '
  hint: After SSH connection, known_hosts file is created
  validation:
    type: command-output
    command: sshpass -p 'password123' ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/tmp/known
      testuser@localhost 'echo connected' 2>/dev/null && test -f /tmp/known && echo
      'known_hosts'
    matcher: contains
    expected: known
- id: execute-remote-commands
  title: Execute Commands Remotely
  description: "**Run Commands Without Interactive Shell:**\n\nssh user@host 'command'\n\
    \n**Examples:**\n\nCheck disk space on remote server:\nssh user@server 'df -h'\n\
    \nView remote system info:\nssh user@server 'uname -a'\n\nList files:\nssh user@server\
    \ 'ls -la /var/log'\n\n**Multiple commands:**\n\nUse semicolons or &&:\nssh user@host\
    \ 'cd /var/log; ls -la; pwd'\n\nOr:\nssh user@host 'whoami && hostname && date'\n\
    \n**Command output:**\n- Appears on your local terminal\n- Can redirect locally:\n\
    \  ssh user@host 'cat file.txt' > local_copy.txt\n\n**vs Interactive shell:**\n\
    \nInteractive:\nssh user@host\n$ ls\n$ pwd\n$ exit\n\nNon-interactive:\nssh user@host\
    \ 'ls; pwd'\n(one command, immediate exit)\n\n**Practical uses:**\n\nCheck server\
    \ status:\nssh admin@server 'systemctl status apache2'\n\nTail remote logs:\n\
    ssh admin@server 'tail -f /var/log/syslog'\n\nRun script on remote:\nssh admin@server\
    \ 'bash /opt/scripts/backup.sh'\n\n**Practice:**\n\nGet remote username:\nssh\
    \ -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null testuser@localhost\
    \ 'whoami'\nPassword: password123\n\nGet remote hostname:\nssh testuser@localhost\
    \ 'hostname'\n\nCheck remote disk space:\nssh testuser@localhost 'df -h /'\n\n\
    **Try executing a remote command:**\nssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null\
    \ testuser@localhost 'pwd'\n"
  hint: Use ssh user@host 'command' to execute remotely
  validation:
    type: command-output
    command: sshpass -p 'password123' ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
      testuser@localhost 'echo SUCCESS' 2>/dev/null
    matcher: contains
    expected: SUCCESS
- id: ssh-config
  title: SSH Client Configuration
  description: "**SSH Config File: ~/.ssh/config**\n\nSimplify SSH connections with\
    \ configuration file.\n\n**Without config:**\nssh -p 2222 -i ~/.ssh/mykey.pem\
    \ john@very-long-hostname.example.com\n\n**With config:**\nssh myserver\n\n**Config\
    \ file format:**\n\n```\nHost myserver\n    HostName very-long-hostname.example.com\n\
    \    User john\n    Port 2222\n    IdentityFile ~/.ssh/mykey.pem\n```\n\n**Common\
    \ options:**\n\nHostName       Real hostname or IP\nUser           Username\n\
    Port           SSH port (default: 22)\nIdentityFile   Path to private key\nForwardAgent\
    \   Enable SSH agent forwarding\nServerAliveInterval  Keep connection alive\n\n\
    **Multiple server configs:**\n\n```\nHost dev\n    HostName dev.example.com\n\
    \    User developer\n    Port 22\n\nHost prod\n    HostName prod.example.com\n\
    \    User admin\n    Port 2222\n    IdentityFile ~/.ssh/prod_key\n\nHost *.internal\n\
    \    User root\n    Port 22\n    StrictHostKeyChecking no\n```\n\n**Wildcards:**\n\
    \nHost *\n    ServerAliveInterval 60\n\nApplies to all hosts!\n\n**Create example\
    \ config:**\n\ncat > ~/.ssh/config << 'EOF'\n# Development server\nHost devserver\n\
    \    HostName localhost\n    User testuser\n    Port 22\n    StrictHostKeyChecking\
    \ no\n    UserKnownHostsFile /dev/null\n\n# Admin access\nHost adminserver\n \
    \   HostName localhost\n    User admin\n    Port 22\nEOF\n\nchmod 600 ~/.ssh/config\n\
    \n**Use configured host:**\nssh devserver\n(connects to localhost as testuser!)\n\
    \n**Benefits:**\n- Shorter commands\n- Consistent settings\n- Easy to share (remove\
    \ sensitive data)\n- Tab completion works\n\n**Create your config:**\nmkdir -p\
    \ ~/.ssh\ncat > ~/.ssh/config << 'EOF'\nHost testserver\n    HostName localhost\n\
    \    User testuser\nEOF\nchmod 600 ~/.ssh/config\n"
  hint: Create ~/.ssh/config with Host entries
  validation:
    type: file-exists
    path: /home/learner/.ssh/config
    matcher: exists
- id: file-permissions
  title: SSH File Permissions
  description: '**Critical: SSH Requires Correct Permissions**


    SSH refuses to work if files have wrong permissions (security!).


    **Required permissions:**


    ~/.ssh directory:

    chmod 700 ~/.ssh

    (owner: read, write, execute; others: nothing)


    ~/.ssh/config:

    chmod 600 ~/.ssh/config

    (owner: read, write; others: nothing)


    Private keys (~/.ssh/id_rsa):

    chmod 600 ~/.ssh/id_rsa

    (owner: read, write; others: nothing)


    Public keys (~/.ssh/id_rsa.pub):

    chmod 644 ~/.ssh/id_rsa.pub

    (owner: read, write; others: read)


    Authorized keys (~/.ssh/authorized_keys):

    chmod 600 ~/.ssh/authorized_keys

    (owner: read, write; others: nothing)


    **Why so strict?**


    Security! If others can read your private key, they can impersonate you.


    **Common error:**


    ```

    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    @         WARNING: UNPROTECTED PRIVATE KEY FILE!      @

    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    Permissions 0644 for ''/home/user/.ssh/id_rsa'' are too open.

    It is required that your private key files are NOT accessible by others.

    ```


    Fix: chmod 600 ~/.ssh/id_rsa


    **Ownership:**


    All SSH files must be owned by you:

    chown -R $USER:$USER ~/.ssh


    **Quick fix script:**


    ```bash

    chmod 700 ~/.ssh

    chmod 600 ~/.ssh/config

    chmod 600 ~/.ssh/id_*

    chmod 644 ~/.ssh/id_*.pub

    chmod 600 ~/.ssh/authorized_keys

    ```


    **Check permissions:**

    ls -la ~/.ssh/


    Should show:

    drwx------  (700) for .ssh directory

    -rw-------  (600) for config and keys


    **Practice:**

    ls -la ~/.ssh/

    chmod 700 ~/.ssh

    chmod 600 ~/.ssh/config

    ls -la ~/.ssh/

    '
  hint: Use chmod 700 for .ssh directory, 600 for config and keys
  validation:
    type: command-output
    command: chmod 700 /home/learner/.ssh && stat -c '%a' /home/learner/.ssh
    matcher: contains
    expected: '700'
- id: common-options
  title: Common SSH Options and Flags
  description: '**Useful SSH Command Options:**


    **-v: Verbose (debugging)**

    ssh -v user@host


    Shows detailed connection process:

    - Key exchange

    - Authentication attempts

    - Cipher selection

    - Connection stages


    Multiple v''s for more detail:

    ssh -vv user@host

    ssh -vvv user@host (very verbose)


    **-p: Specify port**

    ssh -p 2222 user@host


    Default is 22, but some servers use custom ports.


    **-i: Specify identity file (private key)**

    ssh -i ~/.ssh/mykey.pem user@host


    Use specific key instead of default (~/.ssh/id_rsa).


    **-L: Local port forwarding (tunnel)**

    ssh -L 8080:localhost:80 user@host


    Access remote service through SSH tunnel.


    **-R: Remote port forwarding**

    ssh -R 8080:localhost:80 user@host


    Expose local service to remote server.


    **-N: No command (just tunneling)**

    ssh -N -L 8080:localhost:80 user@host


    Don''t execute remote commands, just forward ports.


    **-f: Run in background**

    ssh -f -N -L 8080:localhost:80 user@host


    Tunnel runs in background, terminal free.


    **-A: Enable agent forwarding**

    ssh -A user@host


    Use local SSH keys on remote server.


    **-X: X11 forwarding (GUI apps)**

    ssh -X user@host

    (run graphical applications remotely)


    **-C: Enable compression**

    ssh -C user@host


    Compresses data (good for slow connections).


    **-o: Set options**

    ssh -o StrictHostKeyChecking=no user@host

    ssh -o ConnectTimeout=10 user@host


    **Common option combinations:**


    Quick connection ignoring host key:

    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null user@host


    Verbose with specific key:

    ssh -v -i ~/.ssh/key user@host


    Background tunnel with compression:

    ssh -f -N -C -L 8080:localhost:80 user@host


    **Practice:**

    ssh -v -o StrictHostKeyChecking=no testuser@localhost ''hostname''

    (verbose output shows connection details)

    '
  hint: Use -v for verbose, -p for port, -i for key file
  validation:
    type: command-output
    command: sshpass -p 'password123' ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null
      testuser@localhost 'echo options' 2>/dev/null
    matcher: contains
    expected: options
- id: ssh-escape-sequences
  title: SSH Escape Sequences
  description: '**SSH Escape Sequences: Control Active Session**


    While connected to SSH, use escape sequences to control the connection.


    **Activate escape:**

    Press Enter, then tilde (~), then command


    **Common sequences:**


    ~.  Disconnect immediately

    ~^Z Suspend SSH (background)

    ~#  List forwarded connections

    ~?  Show help


    **When to use:**


    **~.** - Force disconnect

    Useful when:

    - Connection frozen

    - Server not responding

    - Need to exit quickly


    Instead of: Closing terminal window


    **~^Z** - Suspend SSH

    Useful when:

    - Need to work locally temporarily

    - Come back with: fg


    **Example workflow:**


    1. Connect: ssh user@server

    2. Suspend: Enter, ~, Ctrl+Z

    3. Work locally: ls, cat file, etc.

    4. Resume: fg

    5. Disconnect: Enter, ~, .


    **Why escape sequences?**


    - Server frozen but SSH still responds

    - Network issues prevent normal exit

    - Need to interrupt hanging command


    **Note:**

    ~ must be first character after Enter


    Wrong: ls ~.

    Right: (press Enter) ~.


    **Show help:**

    ~?


    Displays all available escape sequences.


    **In practice:**


    Most users just type ''exit'' or Ctrl+D.

    Escape sequences are for special cases.


    **Connection troubleshooting:**


    If stuck:

    1. Try: exit

    2. Try: Ctrl+D

    3. Try: Enter ~.

    4. Last resort: Close terminal


    **Remember:**

    ~. is your emergency exit!

    '
  hint: Escape sequences start with ~ after Enter
  validation:
    type: command-output
    command: 'echo ''Escape sequences: ~. (disconnect), ~^Z (suspend), ~? (help)''
      | grep ''~\.'''
    matcher: contains
    expected: ~.
- id: connection-timeout
  title: Keep-Alive and Timeouts
  description: "**SSH Connection Timeouts:**\n\nSSH connections can drop due to:\n\
    - Idle timeout\n- Network issues\n- Firewall rules\n- NAT translation timeout\n\
    \n**Client-side keep-alive:**\n\nIn ~/.ssh/config:\n```\nHost *\n    ServerAliveInterval\
    \ 60\n    ServerAliveCountMax 3\n```\n\nServerAliveInterval: Send packet every\
    \ 60 seconds\nServerAliveCountMax: Disconnect after 3 failed packets\n\nEffectively:\
    \ Disconnect after 180s (3min) of no response.\n\n**Command line:**\nssh -o ServerAliveInterval=60\
    \ user@host\n\n**Server-side keep-alive:**\n\nIn /etc/ssh/sshd_config (server):\n\
    ```\nClientAliveInterval 60\nClientAliveCountMax 3\n```\n\n**Connection timeout:**\n\
    \nssh -o ConnectTimeout=10 user@host\n\nFail if connection not established in\
    \ 10 seconds.\n\n**Persistent connections:**\n\nControlMaster for connection sharing:\n\
    ```\nHost *\n    ControlMaster auto\n    ControlPath ~/.ssh/sockets/%r@%h:%p\n\
    \    ControlPersist 10m\n```\n\nBenefits:\n- Reuse existing connections\n- Faster\
    \ subsequent connections\n- Share authentication\n\n**Create robust config:**\n\
    \ncat >> ~/.ssh/config << 'EOF'\n\n# Keep-alive settings\nHost *\n    ServerAliveInterval\
    \ 60\n    ServerAliveCountMax 3\n    ConnectTimeout 10\nEOF\n\n**Why important?**\n\
    \n- Long-running tasks don't timeout\n- Survives temporary network blips\n- Prevents\
    \ frustrating disconnections\n\n**Test connection:**\nssh -o ServerAliveInterval=5\
    \ -o ConnectTimeout=10 testuser@localhost 'sleep 10; echo done'\n\n**Update your\
    \ config with keep-alive:**\ncat >> ~/.ssh/config << 'EOF'\n\nHost *\n    ServerAliveInterval\
    \ 60\nEOF\n"
  hint: Add ServerAliveInterval to ~/.ssh/config for keep-alive
  validation:
    type: command-output
    command: grep -i 'ServerAliveInterval\|KeepAlive' /home/learner/.ssh/config 2>/dev/null
      || echo 'config'
    matcher: contains
    expected: ''
completion:
  message: "\U0001F389 SSH BASICS MASTERED! \U0001F389\n\nYou've learned the fundamentals\
    \ of SSH for secure remote access!\n\n**What You've Learned:**\n\n✓ SSH concepts\
    \ and architecture\n✓ SSH command syntax and connection\n✓ Host key verification\
    \ and security\n✓ Executing remote commands\n✓ SSH client configuration\n✓ File\
    \ permissions for SSH\n✓ Common SSH options and flags\n✓ Escape sequences\n✓ Keep-alive\
    \ and timeout settings\n\n**SSH Command Reference:**\n\n**Basic Connection:**\n\
    ssh user@hostname\nssh user@192.168.1.10\nssh -p 2222 user@host\n\n**Remote Commands:**\n\
    ssh user@host 'command'\nssh user@host 'ls -la'\nssh user@host 'df -h && uptime'\n\
    \n**Common Options:**\n-p PORT        Specify port\n-i KEYFILE     Use specific\
    \ key\n-v             Verbose (debugging)\n-A             Agent forwarding\n-X\
    \             X11 forwarding\n-C             Compression\n-N             No command\
    \ (tunnel only)\n-f             Background\n\n**Important Options:**\n-o StrictHostKeyChecking=no\n\
    -o UserKnownHostsFile=/dev/null\n-o ServerAliveInterval=60\n-o ConnectTimeout=10\n\
    \n**SSH Configuration File:**\n\nLocation: ~/.ssh/config\n\nFormat:\n```\nHost\
    \ alias\n    HostName real-hostname\n    User username\n    Port 22\n    IdentityFile\
    \ ~/.ssh/key\n\nHost *\n    ServerAliveInterval 60\n    ServerAliveCountMax 3\n\
    ```\n\n**File Permissions:**\n~/.ssh/                  700 (drwx------)\n~/.ssh/config\
    \            600 (-rw-------)\n~/.ssh/id_rsa            600 (-rw-------)\n~/.ssh/id_rsa.pub\
    \        644 (-rw-r--r--)\n~/.ssh/authorized_keys   600 (-rw-------)\n\n**Escape\
    \ Sequences:**\n~.      Disconnect\n~^Z     Suspend (background)\n~#      List\
    \ forwarded connections\n~?      Show help\n\n**Security Best Practices:**\n☑\
    \ Never share private keys\n☑ Use correct file permissions\n☑ Verify host keys\
    \ on first connection\n☑ Use SSH keys instead of passwords\n☑ Keep SSH client\
    \ updated\n☑ Use specific ports (not default 22)\n☑ Enable keep-alive for stable\
    \ connections\n\n**Common Use Cases:**\n- Remote server administration\n- Deploy\
    \ applications\n- Access cloud servers\n- Run remote commands\n- Monitor logs\
    \ (tail -f)\n- Execute scripts remotely\n\n**Troubleshooting:**\n\nConnection\
    \ refused:\n- Check SSH service is running\n- Verify port (default 22)\n- Check\
    \ firewall rules\n\nPermission denied:\n- Check username\n- Verify authentication\
    \ method\n- Check key permissions (600)\n\nHost key changed:\n- Remove old key\
    \ from known_hosts\n- ssh-keygen -R hostname\n\nConnection timeout:\n- Check network\
    \ connectivity\n- Verify hostname/IP\n- Use -o ConnectTimeout=10\n\n**Next Steps:**\n\
    - SSH key-based authentication\n- SSH agent and key management\n- SCP and SFTP\
    \ for file transfers\n- SSH tunneling and port forwarding\n- SSH security hardening\n\
    - Bastion hosts and jump servers\n\nYou now have the foundation for secure remote\
    \ server access!\n\nGREAT WORK!\n"
  xp: 200
  unlocks:
  - linux/week14/ssh-keys-intermediate
  - linux/week14/scp-sftp-intermediate
