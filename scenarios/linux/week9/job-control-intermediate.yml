mission:
  id: linux/week9/job-control-intermediate
  title: Job Control and Process Management
  difficulty: intermediate
  description: Master job control, process priorities, signals, and advanced process
    management techniques
  estimated_time: 35
  tags:
  - linux
  - processes
  - job-control
  - signals
  - intermediate
  - week9
  - cst8207
environment:
  image: ubuntu:22.04
  workdir: /home/learner
  setup:
  - apt-get update -qq && apt-get install -y -qq procps bc
  - mkdir -p /home/learner/scripts
steps:
- id: job-control-basics
  title: Advanced Job Control
  description: '**Job Control: Managing Multiple Tasks**


    Job control lets you run multiple programs from one terminal.


    **Job vs Process:**

    - **Process**: Any running program (system-wide)

    - **Job**: Process started from your shell


    Every job is a process, but not every process is a job!


    **Job states:**

    - **Running**: Actively executing

    - **Stopped**: Paused (Ctrl+Z)

    - **Done**: Finished


    **Job control commands:**

    jobs      List jobs

    fg [%n]   Foreground job n

    bg [%n]   Background job n

    Ctrl+Z    Stop current job

    Ctrl+C    Kill current job


    **Job numbers:**

    %1        Job 1

    %2        Job 2

    %+        Current job

    %-        Previous job

    %%        Current job (same as %+)


    **Example workflow:**


    Start job:

    sleep 100


    Pause: Ctrl+Z

    [1]+ Stopped  sleep 100


    Continue in background:

    bg %1

    [1]+ sleep 100 &


    List jobs:

    jobs

    [1]+ Running  sleep 100 &


    Bring to foreground:

    fg %1


    Kill: Ctrl+C


    **Multiple jobs:**


    sleep 100 &

    [1] 12345


    sleep 200 &

    [2] 12346


    sleep 300 &

    [3] 12347


    jobs

    [1]   Running   sleep 100 &

    [2]-  Running   sleep 200 &

    [3]+  Running   sleep 300 &


    +  = current (most recent)

    -  = previous


    **Control specific jobs:**

    fg %1     # Foreground job 1

    bg %2     # Background job 2

    kill %3   # Kill job 3


    **Detach job from terminal:**

    disown %1


    Now job continues even if you close terminal!


    **Practice:**

    sleep 60 &

    sleep 120 &

    jobs

    fg %1

    Ctrl+Z

    bg

    jobs

    kill %1 %2

    '
  hint: Use jobs to list, fg/bg to control, Ctrl+Z to pause
  validation:
    type: command-output
    command: sleep 10 & sleep 20 & jobs | wc -l
    matcher: regex
    expected: '[1-9]'
- id: process-signals
  title: Understanding Signals
  description: "**Signals: Inter-Process Communication**\n\nSignals are notifications\
    \ sent to processes.\n\n**Common signals:**\n\n| Signal | Number | Meaning | Can\
    \ Catch? |\n|--------|--------|---------|------------|\n| SIGHUP | 1 | Hangup\
    \ (terminal closed) | Yes |\n| SIGINT | 2 | Interrupt (Ctrl+C) | Yes |\n| SIGQUIT\
    \ | 3 | Quit (Ctrl+\\\\) | Yes |\n| SIGKILL | 9 | Kill (force) | No |\n| SIGTERM\
    \ | 15 | Terminate (graceful) | Yes |\n| SIGSTOP | 19 | Stop (pause) | No |\n\
    | SIGCONT | 18 | Continue (resume) | Yes |\n| SIGUSR1 | 10 | User-defined | Yes\
    \ |\n| SIGUSR2 | 12 | User-defined | Yes |\n\n**Sending signals:**\n\nBy number:\n\
    kill -9 PID      # SIGKILL\nkill -15 PID     # SIGTERM\n\nBy name:\nkill -KILL\
    \ PID   # SIGKILL\nkill -TERM PID   # SIGTERM\nkill -HUP PID    # SIGHUP\n\n**Signal\
    \ meanings:**\n\n**SIGTERM (15) - Graceful shutdown:**\n- Default signal\n- Process\
    \ can catch and cleanup\n- Saves data, closes files\n- Preferred method\n\n**SIGKILL\
    \ (9) - Force kill:**\n- Cannot be caught or ignored\n- Immediate termination\n\
    - No cleanup\n- Last resort only!\n\n**SIGINT (2) - Interrupt:**\n- Sent by Ctrl+C\n\
    - Like SIGTERM but from keyboard\n- Process can catch\n\n**SIGHUP (1) - Hangup:**\n\
    - Originally: terminal disconnected\n- Now: reload configuration\n- Example: nginx\
    \ -s reload\n\n**SIGSTOP/SIGCONT - Pause/Resume:**\n- SIGSTOP: Pause process\n\
    - SIGCONT: Resume process\n- Like Ctrl+Z and bg/fg\n\n**Proper kill procedure:**\n\
    \n1. Try SIGTERM first:\n   kill PID\n   wait...\n\n2. If not responding:\n  \
    \ kill -TERM PID\n   wait longer...\n\n3. Last resort:\n   kill -9 PID\n\n**Signal\
    \ to all processes by name:**\nkillall -TERM firefox\npkill -HUP nginx\n\n**Practice:**\n\
    \nStart process:\nsleep 100 &\nPID=$!\n\nSend SIGSTOP (pause):\nkill -STOP $PID\n\
    \nCheck (should show T state):\nps -p $PID -o pid,stat,cmd\n\nSend SIGCONT (resume):\n\
    kill -CONT $PID\n\nCheck (should show S state):\nps -p $PID -o pid,stat,cmd\n\n\
    Kill gracefully:\nkill -TERM $PID\n"
  hint: Use kill -SIGNAL PID, try TERM before KILL
  validation:
    type: command-output
    command: kill -l | grep -E 'TERM|KILL|INT' | wc -l
    matcher: regex
    expected: '[3-9]'
- id: process-priorities
  title: Process Priorities and Nice Values
  description: "**Process Priority: Who Gets CPU First?**\n\n**Nice value:**\n- Range:\
    \ -20 (highest priority) to 19 (lowest)\n- Default: 0\n- Lower number = higher\
    \ priority\n- Higher number = \"nicer\" to other processes\n\n**Who can set priorities:**\n\
    - Any user: Increase nice (lower priority)\n- Root only: Decrease nice (higher\
    \ priority)\n\n**View priorities:**\nps -el | head\nps -eo pid,ni,comm\n\nNI column\
    \ shows nice value.\n\n**Start with nice value:**\nnice -n 10 command\n\nExample:\n\
    nice -n 10 sleep 100 &\n\nVery low priority:\nnice -n 19 ./cpu_intensive_task\
    \ &\n\nHigh priority (requires root):\nnice -n -10 ./important_task &\n\n**Change\
    \ nice value (renice):**\n\nLower priority (anyone):\nrenice +5 PID\n\nRaise priority\
    \ (root only):\nsudo renice -5 PID\n\nBy user:\nsudo renice +10 -u username\n\n\
    By group:\nsudo renice +10 -g groupname\n\n**Use cases:**\n\n**Low priority (high\
    \ nice):**\n- Backup jobs\n- Log processing\n- Maintenance tasks\n- Batch processing\n\
    \nExample:\nnice -n 19 tar -czf backup.tar.gz /data/ &\n\n**High priority (low\
    \ nice):**\n- Interactive applications\n- Real-time processing\n- Critical services\n\
    - Database servers\n\n**CPU scheduling:**\n\nNice affects CPU scheduling:\n- Nice\
    \ 0: Normal share\n- Nice 19: Gets CPU when idle\n- Nice -20: Gets CPU frequently\n\
    \n**Practice:**\n\nStart low priority task:\nnice -n 15 sleep 100 &\nPID=$!\n\n\
    Check nice value:\nps -o pid,ni,comm -p $PID\n\nIncrease priority (lower nice):\n\
    renice 10 $PID\n\nCheck again:\nps -o pid,ni,comm -p $PID\n\n**CPU-bound script\
    \ for testing:**\n\ncat > scripts/cpu_test.sh << 'EOF'\n#!/bin/bash\n# CPU-intensive\
    \ task\ni=0\nwhile [ $i -lt 1000000 ]; do\n  result=$(echo \"scale=10; $i * 3.14159\"\
    \ | bc)\n  i=$((i + 1))\ndone\nEOF\n\nchmod +x scripts/cpu_test.sh\n\nRun with\
    \ different priorities:\nnice -n 0 ./scripts/cpu_test.sh &\nnice -n 19 ./scripts/cpu_test.sh\
    \ &\n\nMonitor with top:\ntop\n(Press M to sort by CPU, see NI column)\n"
  hint: Use nice -n VALUE command, renice VALUE PID to adjust
  validation:
    type: command-output
    command: nice -n 10 sleep 10 & PID=$! && ps -o pid,ni,comm -p $PID | grep sleep
    matcher: contains
    expected: '10'
- id: nohup-screen
  title: Persistent Processes with nohup
  description: "**nohup: Run After Logout**\n\nProblem: Jobs die when you close terminal.\n\
    \nSolution: nohup (no hangup)\n\n**Basic usage:**\nnohup command &\n\n**What nohup\
    \ does:**\n- Ignores SIGHUP signal\n- Redirects output to nohup.out\n- Process\
    \ continues after logout\n\n**Example:**\nnohup sleep 300 &\n[1] 12345\nnohup:\
    \ ignoring input and appending output to 'nohup.out'\n\nClose terminal, process\
    \ still runs!\n\n**Custom output file:**\nnohup command > output.log 2>&1 &\n\n\
    **Practical examples:**\n\nLong-running script:\nnohup ./long_script.sh > script.log\
    \ 2>&1 &\n\nBackground server:\nnohup python3 server.py > server.log 2>&1 &\n\n\
    Download:\nnohup wget large_file.zip > download.log 2>&1 &\n\n**Combining nohup\
    \ and nice:**\nnohup nice -n 10 ./backup.sh > backup.log 2>&1 &\n\n**View output:**\n\
    tail -f nohup.out\n\n**Find nohup processes:**\nps aux | grep [n]ohup\n\n**Alternative:\
    \ disown**\n\nStart process:\nsleep 300 &\n\nDetach from shell:\ndisown %1\n\n\
    Now immune to SIGHUP!\n\n**Difference:**\n- nohup: Set before starting\n- disown:\
    \ Set after starting\n\n**Practice:**\n\nStart with nohup:\nnohup sleep 200 >\
    \ /tmp/nohup_test.log 2>&1 &\necho $!\n\nVerify running:\nps aux | grep sleep\n\
    \nCheck output:\ncat /tmp/nohup_test.log\n\n**Long-running task simulation:**\n\
    \ncat > scripts/long_task.sh << 'EOF'\n#!/bin/bash\nfor i in {1..60}; do\n  echo\
    \ \"Progress: $i/60 at $(date)\"\n  sleep 1\ndone\necho \"Task complete!\"\nEOF\n\
    \nchmod +x scripts/long_task.sh\n\nRun with nohup:\nnohup ./scripts/long_task.sh\
    \ > task.log 2>&1 &\n\nMonitor:\ntail -f task.log\n(Ctrl+C to stop watching, process\
    \ continues)\n"
  hint: Use nohup command & to run immune to hangup
  validation:
    type: command-output
    command: nohup sleep 10 > /tmp/nohup_test.log 2>&1 & sleep 1 && ps aux | grep
      '[n]ohup'
    matcher: contains
    expected: ''
- id: process-monitoring
  title: Advanced Process Monitoring
  description: '**watch: Continuous Monitoring**


    Run command repeatedly, show output.


    **Basic usage:**

    watch command


    Update every 2 seconds (default).


    **Custom interval:**

    watch -n 5 command

    (Update every 5 seconds)


    **Highlight changes:**

    watch -d command


    **Examples:**


    Monitor processes:

    watch ''ps aux | grep python''


    Monitor disk space:

    watch -n 10 df -h


    Monitor memory:

    watch free -h


    Monitor jobs:

    watch jobs


    Monitor specific process:

    watch -n 1 ''ps -p PID -o pid,stat,%cpu,%mem,cmd''


    **pgrep with monitoring:**


    Watch for process:

    watch -n 1 ''pgrep -l firefox''


    Count processes:

    watch -n 1 ''ps aux | wc -l''


    **Custom monitoring script:**


    cat > scripts/monitor_cpu.sh << ''EOF''

    #!/bin/bash

    echo "=== Top CPU Users ==="

    ps aux --sort=-%cpu | head -6

    echo ""

    echo "=== Top Memory Users ==="

    ps aux --sort=-%mem | head -6

    echo ""

    echo "=== System Load ==="

    uptime

    EOF


    chmod +x scripts/monitor_cpu.sh


    Watch it:

    watch -n 2 ./scripts/monitor_cpu.sh


    **Process tree monitoring:**

    watch -n 1 ''pstree -p $$''


    **pidstat: Per-process statistics**

    (If sysstat installed)

    pidstat 1

    pidstat -p PID 1


    **strace: Trace system calls**


    Debug what process is doing:

    strace -p PID


    Trace new process:

    strace command


    **lsof: Open files**


    Files opened by process:

    lsof -p PID


    Processes using file:

    lsof /path/to/file


    Network connections:

    lsof -i


    **/proc filesystem monitoring:**


    CPU usage:

    cat /proc/PID/stat


    Memory info:

    cat /proc/PID/status | grep -i mem


    Open files:

    ls -l /proc/PID/fd/


    **Practice:**


    Start background process:

    sleep 300 &

    PID=$!


    Monitor it:

    watch -n 1 "ps -p $PID -o pid,stat,%cpu,%mem,cmd"


    (Ctrl+C to exit)


    View its /proc info:

    cat /proc/$PID/status | head -20

    ls -l /proc/$PID/fd/

    '
  hint: Use watch for continuous monitoring, /proc for detailed info
  validation:
    type: command-output
    command: watch -n 1 'ps aux | head -5' & sleep 2 && jobs | grep watch && kill
      %1
    matcher: contains
    expected: watch
- id: practical-scenarios
  title: Practical Process Management Scenarios
  description: "**Real-World Process Management:**\n\n**Scenario 1: Find and kill\
    \ resource hog**\n\nFind CPU hog:\nps aux --sort=-%cpu | head -5\n\nKill it:\n\
    kill [PID]\n\nOr one-liner:\nkill $(ps aux --sort=-%cpu | awk 'NR==2 {print $2}')\n\
    \n**Scenario 2: Restart hung service**\n\nFind process:\npgrep nginx\n\nTry graceful:\n\
    kill -HUP [PID]\n\nIf stuck:\nkill -TERM [PID]\n\nLast resort:\nkill -9 [PID]\n\
    \nRestart:\nservice nginx start\n\n**Scenario 3: Run maintenance task**\n\nLow\
    \ priority, immune to logout:\nnohup nice -n 19 ./maintenance.sh > maint.log 2>&1\
    \ &\n\nMonitor progress:\ntail -f maint.log\n\n**Scenario 4: Kill all user processes**\n\
    \npkill -u username\nkillall -u username\n\n**Scenario 5: Find processes using\
    \ file**\n\nlsof /var/log/app.log\nfuser /var/log/app.log\n\nKill them:\nfuser\
    \ -k /var/log/app.log\n\n**Scenario 6: Monitor suspect process**\n\nwatch -n 1\
    \ 'ps -p PID -o pid,stat,%cpu,%mem,cmd'\n\nOr:\ntop -p PID\n\n**Scenario 7: Clean\
    \ up zombies**\n\nFind zombies:\nps aux | grep Z\n\nFind parent:\nps -ef | grep\
    \ [PPID]\n\nKill parent (zombies will be cleaned):\nkill -TERM [PPID]\n\n**Scenario\
    \ 8: Batch job control**\n\nStart multiple jobs:\nfor i in {1..5}; do\n  nice\
    \ -n 15 ./job$i.sh > job$i.log 2>&1 &\ndone\n\nMonitor all:\nwatch jobs\n\nKill\
    \ all:\njobs -p | xargs kill\n\n**Create test scenario:**\n\ncat > scripts/resource_test.sh\
    \ << 'EOF'\n#!/bin/bash\n# Simulated resource-intensive task\necho \"Starting\
    \ task at $(date)\"\ni=0\nwhile [ $i -lt 100 ]; do\n  # CPU work\n  result=$(echo\
    \ \"scale=5; $i * 3.14159\" | bc 2>/dev/null)\n  echo \"Progress: $i% at $(date)\"\
    \n  sleep 1\n  i=$((i + 1))\ndone\necho \"Task complete at $(date)\"\nEOF\n\n\
    chmod +x scripts/resource_test.sh\n\nRun it:\nnohup nice -n 10 ./scripts/resource_test.sh\
    \ > resource.log 2>&1 &\nPID=$!\n\nMonitor:\nwatch -n 2 \"ps -p $PID -o pid,ni,stat,%cpu,cmd\
    \ && tail -3 resource.log\"\n\nPractice finding and managing it!\n"
  hint: Combine ps, kill, nice, nohup for real-world scenarios
  validation:
    type: file-exists
    path: /home/learner/scripts/resource_test.sh
    matcher: exists
completion:
  message: "\U0001F389 JOB CONTROL MASTERED! \U0001F389\n\nYou've mastered intermediate\
    \ process and job management!\n\n**What You've Learned:**\n\n✓ Advanced job control\
    \ techniques\n✓ Process signals and communication\n✓ Process priorities (nice/renice)\n\
    ✓ Persistent processes (nohup)\n✓ Advanced monitoring techniques\n✓ Real-world\
    \ management scenarios\n\n**Quick Reference:**\n\n**Job Control:**\njobs     \
    \           List jobs\nfg [%n]             Foreground job\nbg [%n]           \
    \  Background job\ndisown [%n]         Detach job\nCtrl+Z              Pause job\n\
    Ctrl+C              Kill job\n\n**Signals:**\nkill PID            Send SIGTERM\
    \ (15)\nkill -9 PID         Send SIGKILL (force)\nkill -HUP PID       Send SIGHUP\
    \ (reload)\nkill -STOP PID      Pause process\nkill -CONT PID      Resume process\n\
    killall name        Kill all by name\npkill pattern       Kill by pattern\n\n\
    **Priority:**\nnice -n 10 cmd      Start with nice 10\nnice -n -5 cmd      High\
    \ priority (root)\nrenice 5 PID        Change to nice 5\nrenice -5 PID       Higher\
    \ priority (root)\n\n**Persistent:**\nnohup cmd &         Immune to hangup\nnohup\
    \ cmd > log 2>&1 &   With output\ndisown %1           Detach existing job\n\n\
    **Monitoring:**\nwatch cmd           Repeat command\nwatch -n 5 cmd      Every\
    \ 5 seconds\nwatch -d cmd        Highlight changes\ntop -p PID          Monitor\
    \ process\nlsof -p PID         Open files\nstrace -p PID       Trace syscalls\n\
    \n**Signal Numbers:**\n1  SIGHUP     Hangup\n2  SIGINT     Interrupt (Ctrl+C)\n\
    9  SIGKILL    Force kill\n15 SIGTERM    Terminate (graceful)\n18 SIGCONT    Continue\n\
    19 SIGSTOP    Stop\n\n**Nice Values:**\n-20    Highest priority (root only)\n\
    -10    High priority (root only)\n0      Default priority\n10     Lower priority\n\
    19     Lowest priority\n\n**Best Practices:**\n\n☑ Use SIGTERM before SIGKILL\n\
    ☑ Use nohup for long-running tasks\n☑ Use nice for CPU-intensive jobs\n☑ Monitor\
    \ resource usage regularly\n☑ Clean up finished jobs\n☑ Use disown or nohup for\
    \ persistent tasks\n☑ Check process state before killing\n☑ Use appropriate signals\n\
    \n**Common Patterns:**\n\nBackground task with low priority:\nnohup nice -n 15\
    \ ./task.sh > task.log 2>&1 &\n\nMonitor specific process:\nwatch -n 1 'ps -p\
    \ PID -o pid,%cpu,%mem,stat,cmd'\n\nFind and kill gracefully:\nkill $(pgrep process_name)\n\
    sleep 5\nkill -9 $(pgrep process_name)  # If still alive\n\nRun batch jobs:\n\
    for script in *.sh; do\n  nohup nice -n 10 ./$script > $script.log 2>&1 &\ndone\n\
    \n**Troubleshooting:**\n\nProcess won't die:\n1. Check if it's catching signals\n\
    2. Try SIGTERM first\n3. Wait a moment\n4. Try SIGKILL if necessary\n\nZombie\
    \ processes:\n1. Find parent (PPID)\n2. Kill parent process\n3. init will clean\
    \ up zombies\n\nHigh CPU usage:\n1. Identify with top/ps\n2. Check if legitimate\n\
    3. Renice or kill if needed\n\nYou now have professional process management skills!\n\
    \nEXCELLENT WORK!\n"
  xp: 300
  unlocks:
  - linux/week9/process-management-advanced
