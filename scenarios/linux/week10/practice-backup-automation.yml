mission:
  id: linux/week10/practice-backup-automation
  title: Build Production Backup System
  difficulty: advanced
  description: Design and implement a complete automated backup solution with scheduling,
    compression, rotation, monitoring, and recovery procedures
  estimated_time: 60
  tags:
  - linux
  - practice
  - cron
  - compression
  - automation
  - expert
  - week10
  - cst8207
environment:
  image: ubuntu:22.04
  workdir: /opt/backup-system
  setup:
  - apt-get update -qq && apt-get install -y -qq cron rsyslog bzip2 gzip xz-utils
    tar pigz pbzip2 mailutils bc
  - service cron start
  - service rsyslog start
  - useradd -m -s /bin/bash backupuser
  - mkdir -p /opt/backup-system /var/backups/archives /var/backups/logs /var/log/backup
  - chown -R backupuser:backupuser /opt/backup-system /var/backups
  - '# Create production-like application structure

    mkdir -p /srv/application/{config,data,logs,uploads,cache}

    '
  - '# Simulate production data

    cat > /srv/application/config/database.conf << ''EOF''

    host=prod-db-01.internal

    port=5432

    database=production

    user=appuser

    max_connections=200

    EOF

    '
  - 'cat > /srv/application/config/app.conf << ''EOF''

    environment=production

    debug=false

    log_level=INFO

    session_timeout=3600

    EOF

    '
  - "# Create data files\nfor i in {1..20}; do\n  echo \"User $i data: $(date +%s)\"\
    \ > /srv/application/data/user_$i.json\ndone\n"
  - "# Create log files\nfor i in {1..100}; do\n  echo \"$(date) - INFO - Application\
    \ event $i\" >> /srv/application/logs/app.log\ndone\nfor i in {1..50}; do\n  echo\
    \ \"$(date) - ERROR - Exception in module $i\" >> /srv/application/logs/error.log\n\
    done\n"
  - '# Create upload files (simulate various sizes)

    dd if=/dev/urandom of=/srv/application/uploads/file1.bin bs=1M count=5 2>/dev/null

    dd if=/dev/urandom of=/srv/application/uploads/file2.bin bs=1M count=3 2>/dev/null

    '
  - "# Create cache (should not be backed up)\nfor i in {1..30}; do\n  echo \"Cache\
    \ entry $i\" > /srv/application/cache/cache_$i.tmp\ndone\n"
  - chown -R www-data:www-data /srv/application
  - chmod 600 /srv/application/config/*.conf
steps:
- id: understand-requirements
  title: Analyze Production Requirements
  description: "**SCENARIO: Production Backup System**\n\nYou're a DevOps engineer\
    \ tasked with implementing a backup solution for a production application server.\n\
    \n**Application Structure:**\n/srv/application/\n├── config/     ← Configuration\
    \ files (CRITICAL)\n├── data/       ← User data (CRITICAL)\n├── logs/       ←\
    \ Application logs (backup compressed)\n├── uploads/    ← User uploads (CRITICAL)\n\
    └── cache/      ← Temporary files (DO NOT backup)\n\n**Business Requirements:**\n\
    \n1. **Backup Schedule:**\n   - Full backup: Daily at 2:00 AM\n   - Incremental\
    \ backup: Every 6 hours (2,8,14,20)\n   - Log compression: Hourly\n\n2. **Retention\
    \ Policy:**\n   - Keep 7 daily full backups\n   - Keep 28 incremental backups\n\
    \   - Keep 24 compressed log archives\n\n3. **Storage Optimization:**\n   - Use\
    \ parallel compression (pigz)\n   - Exclude cache and temporary files\n   - Compress\
    \ logs with maximum compression\n   - Use incremental backups for efficiency\n\
    \n4. **Reliability:**\n   - Verify all archives after creation\n   - Generate\
    \ checksums (SHA256)\n   - Log all operations with timestamps\n   - Alert on failures\
    \ (write to syslog)\n\n5. **Recovery:**\n   - Document recovery procedures\n \
    \  - Test restoration quarterly\n   - Keep restore scripts ready\n\n**Your Tasks:**\n\
    \nYou must implement:\n1. Full backup script with rotation\n2. Incremental backup\
    \ script\n3. Log compression automation\n4. Verification and checksum generation\n\
    5. Cron scheduling\n6. Monitoring and alerting\n7. Recovery documentation\n8.\
    \ Test restoration procedure\n\n**Explore the application:**\ntree -L 2 /srv/application/\n\
    du -sh /srv/application/*\n\n**No step-by-step guidance!**\nThis is a real-world\
    \ scenario. Plan and implement the complete solution.\n"
  hint: Analyze the directory structure and requirements before coding
  validation:
    type: command-output
    command: ls -la /srv/application/ | wc -l
    matcher: regex
    expected: '[5-9]|[1-9][0-9]'
- id: implement-full-backup
  title: Implement Full Backup System
  description: '**Task: Create Full Backup Script**


    Create: /opt/backup-system/full_backup.sh


    **Requirements:**


    ✓ Backup /srv/application/ to /var/backups/archives/

    ✓ Filename: full_backup_YYYYMMDD_HHMMSS.tar.gz

    ✓ Use parallel compression (pigz)

    ✓ Exclude: cache/, *.tmp, *.log files

    ✓ Include: config/, data/, uploads/

    ✓ Log compression: Compress logs/ separately to logs_YYYYMMDD.tar.bz2

    ✓ Create .snar snapshot file for incremental support

    ✓ Verify archive integrity after creation

    ✓ Generate SHA256 checksum

    ✓ Log all operations to /var/log/backup/full_backup.log

    ✓ Return exit code 0 on success, 1 on failure

    ✓ Rotate old backups (keep last 7)

    ✓ Run as backupuser


    **Log format:**

    [YYYY-MM-DD HH:MM:SS] LEVEL: Message


    **On failure:**

    - Write error to syslog: logger -t backup-system "ERROR: message"

    - Exit with code 1


    **Hints:**

    - Use tar with --listed-incremental for snapshot

    - Verify with: tar -tzf archive.tar.gz > /dev/null

    - Rotation: ls -t | tail -n +8 | xargs rm

    - Parallel: tar --use-compress-program=pigz


    **Success criteria:**

    - Script exists and is executable

    - Creates valid .tar.gz archive

    - Generates checksum file

    - Creates log file with timestamp entries

    - Implements rotation (keeps only 7)

    - Exits with proper codes


    **Test your script:**

    sudo -u backupuser /opt/backup-system/full_backup.sh

    echo "Exit code: $?"

    '
  hint: Create comprehensive backup script with all requirements
  validation:
    type: command-output
    command: test -x /opt/backup-system/full_backup.sh && ls /opt/backup-system/full_backup.sh
    matcher: contains
    expected: full_backup.sh
- id: implement-incremental-backup
  title: Implement Incremental Backup System
  description: '**Task: Create Incremental Backup Script**


    Create: /opt/backup-system/incremental_backup.sh


    **Requirements:**


    ✓ Use same snapshot file as full backup (.snar)

    ✓ Filename: incr_backup_YYYYMMDD_HHMMSS.tar.gz

    ✓ Only backs up changes since last backup (full or incremental)

    ✓ Same exclusions as full backup

    ✓ Use pigz compression

    ✓ Verify archive integrity

    ✓ Generate SHA256 checksum

    ✓ Log to /var/log/backup/incremental_backup.log

    ✓ Rotate old incrementals (keep last 28)

    ✓ Handle case where no snapshot exists (error)


    **Key differences from full backup:**

    - Uses existing .snar file (doesn''t create new one)

    - Smaller archives (only changed files)

    - More frequent execution

    - Different retention policy


    **Error handling:**

    - Check if .snar file exists

    - If not: log error and exit 1

    - Verify source directory exists

    - Check disk space before starting


    **Success criteria:**

    - Script executable

    - Uses snapshot file correctly

    - Creates smaller archives (only changes)

    - Proper rotation (28 backups)

    - Logging and checksums


    **Test:**

    # Run full backup first (creates .snar)

    sudo -u backupuser /opt/backup-system/full_backup.sh


    # Make some changes

    echo "New data" > /srv/application/data/new_file.txt


    # Run incremental

    sudo -u backupuser /opt/backup-system/incremental_backup.sh


    # Verify incremental is smaller

    ls -lh /var/backups/archives/

    '
  hint: Use --listed-incremental with existing snapshot file
  validation:
    type: command-output
    command: test -x /opt/backup-system/incremental_backup.sh && ls /opt/backup-system/incremental_backup.sh
    matcher: contains
    expected: incremental_backup.sh
- id: implement-log-compression
  title: Implement Log Compression
  description: '**Task: Create Log Compression Script**


    Create: /opt/backup-system/compress_logs.sh


    **Requirements:**


    ✓ Compress all .log files in /srv/application/logs/

    ✓ Use maximum bzip2 compression (level 9)

    ✓ Filename: logs_YYYYMMDD_HH.tar.bz2

    ✓ Keep original logs (don''t delete)

    ✓ Output to /var/backups/archives/

    ✓ Verify compressed archive

    ✓ Generate checksum

    ✓ Log to /var/log/backup/log_compression.log

    ✓ Rotate old log archives (keep last 24)

    ✓ Calculate and log compression ratio


    **Compression ratio calculation:**

    ORIGINAL_SIZE=$(du -sb /srv/application/logs/*.log | awk ''{sum+=$1} END {print
    sum}'')

    COMPRESSED_SIZE=$(stat -c %s archive.tar.bz2)

    RATIO=$(echo "scale=1; (1 - $COMPRESSED_SIZE/$ORIGINAL_SIZE) * 100" | bc)


    **Why not delete originals?**

    - Application is still writing to them

    - Separate cleanup job handles old logs

    - Safety: verify backup before deletion


    **Success criteria:**

    - Script executable

    - Uses bzip2 for maximum compression

    - Logs compression ratio

    - Keeps originals intact

    - Proper rotation (24 archives)

    - Verification and checksums


    **Test:**

    sudo -u backupuser /opt/backup-system/compress_logs.sh


    # Check compression ratio

    tail /var/log/backup/log_compression.log


    # Verify logs still exist

    ls /srv/application/logs/

    '
  hint: Use tar -cjf with maximum compression and calculate savings
  validation:
    type: command-output
    command: test -x /opt/backup-system/compress_logs.sh && ls /opt/backup-system/compress_logs.sh
    matcher: contains
    expected: compress_logs.sh
- id: schedule-backups
  title: Schedule All Backup Jobs
  description: "**Task: Configure Cron Scheduling**\n\nCreate: /etc/cron.d/backup-system\n\
    \n**Schedule Requirements:**\n\n1. **Full Backup**: Daily at 2:00 AM\n   0 2 *\
    \ * * backupuser /opt/backup-system/full_backup.sh\n\n2. **Incremental Backup**:\
    \ Every 6 hours (2,8,14,20)\n   0 2,8,14,20 * * * backupuser /opt/backup-system/incremental_backup.sh\n\
    \n3. **Log Compression**: Every hour\n   0 * * * * backupuser /opt/backup-system/compress_logs.sh\n\
    \n4. **Verification Check**: Daily at 3:00 AM (after backups)\n   0 3 * * * backupuser\
    \ /opt/backup-system/verify_backups.sh\n\n**Cron file format:**\n```\n# Backup\
    \ System Automation\n# Managed by: DevOps Team\n# Last updated: YYYY-MM-DD\n\n\
    SHELL=/bin/bash\nPATH=/usr/local/bin:/usr/bin:/bin\nMAILTO=backup-admin@company.com\n\
    \n# Full backup - daily 2 AM\n0 2 * * * backupuser /opt/backup-system/full_backup.sh\
    \ >> /var/log/backup/cron.log 2>&1\n\n# Incremental backups - every 6 hours\n\
    0 2,8,14,20 * * * backupuser /opt/backup-system/incremental_backup.sh >> /var/log/backup/cron.log\
    \ 2>&1\n\n# Log compression - hourly\n0 * * * * backupuser /opt/backup-system/compress_logs.sh\
    \ >> /var/log/backup/cron.log 2>&1\n\n# Verification - daily 3 AM\n0 3 * * * backupuser\
    \ /opt/backup-system/verify_backups.sh >> /var/log/backup/cron.log 2>&1\n```\n\
    \n**Important:**\n- Use system cron (/etc/cron.d/), not user crontab\n- Specify\
    \ username (backupuser)\n- Redirect output to log files\n- Set appropriate PATH\
    \ and SHELL\n- Document each job\n\n**Test scheduling:**\n# Check syntax\ncrontab\
    \ -l -u backupuser 2>/dev/null || cat /etc/cron.d/backup-system\n\n# Test cron\
    \ entries\ngrep -E \"^[^#]\" /etc/cron.d/backup-system\n\n**Success criteria:**\n\
    - File exists: /etc/cron.d/backup-system\n- Proper format with username field\n\
    - All 4 jobs scheduled correctly\n- Environment variables set\n- Output redirected\
    \ to logs\n"
  hint: Create system cron file in /etc/cron.d/ with proper format
  validation:
    type: command-output
    command: test -f /etc/cron.d/backup-system && grep 'backupuser' /etc/cron.d/backup-system
    matcher: contains
    expected: backupuser
- id: implement-verification
  title: Implement Verification System
  description: "**Task: Create Verification Script**\n\nCreate: /opt/backup-system/verify_backups.sh\n\
    \n**Requirements:**\n\n✓ Verify all archives in /var/backups/archives/\n✓ Check\
    \ archive integrity (tar -tzf)\n✓ Verify checksums (sha256sum -c)\n✓ Check for\
    \ required backups (at least 1 full, recent incrementals)\n✓ Calculate total backup\
    \ size\n✓ Report oldest and newest backup\n✓ Log results to /var/log/backup/verification.log\n\
    ✓ Alert to syslog if verification fails\n✓ Generate daily verification report\n\
    \n**Report format:**\n```\n========================================\nBackup Verification\
    \ Report\nDate: YYYY-MM-DD HH:MM:SS\n========================================\n\
    \nTotal Archives: X\nFull Backups: X\nIncremental Backups: X\nLog Archives: X\n\
    \nTotal Size: XX.X GB\nOldest Backup: YYYY-MM-DD HH:MM:SS\nNewest Backup: YYYY-MM-DD\
    \ HH:MM:SS\n\nIntegrity Checks:\n✓ full_backup_20260109.tar.gz - OK\n✓ incr_backup_20260109.tar.gz\
    \ - OK\n✗ logs_20260108.tar.bz2 - FAILED\n\nChecksum Verification:\n✓ 15/15 checksums\
    \ valid\n\nStatus: PASS / FAIL\n========================================\n```\n\
    \n**Verification logic:**\n```bash\nfor archive in *.tar.gz *.tar.bz2; do\n  if\
    \ tar -tf \"$archive\" > /dev/null 2>&1; then\n    echo \"✓ $archive - OK\"\n\
    \  else\n    echo \"✗ $archive - FAILED\"\n    FAILED=1\n  fi\ndone\n```\n\n**Alert\
    \ on failure:**\n```bash\nif [ $FAILED -eq 1 ]; then\n  logger -t backup-system\
    \ -p user.err \"Backup verification failed!\"\n  exit 1\nfi\n```\n\n**Success\
    \ criteria:**\n- Script executable\n- Verifies all archive types\n- Checks checksums\n\
    - Generates formatted report\n- Alerts on failures\n- Proper logging\n\n**Test:**\n\
    sudo -u backupuser /opt/backup-system/verify_backups.sh\ncat /var/log/backup/verification.log\n"
  hint: Test integrity with tar -tf and verify checksums with sha256sum -c
  validation:
    type: command-output
    command: test -x /opt/backup-system/verify_backups.sh && ls /opt/backup-system/verify_backups.sh
    matcher: contains
    expected: verify_backups.sh
- id: implement-monitoring
  title: Implement Monitoring and Alerting
  description: "**Task: Create Monitoring Script**\n\nCreate: /opt/backup-system/monitor.sh\n\
    \n**Requirements:**\n\n✓ Check disk space (alert if < 20% free)\n✓ Check backup\
    \ age (alert if > 25 hours since last full)\n✓ Check for failed backups in logs\n\
    ✓ Monitor backup size trends\n✓ Check cron service status\n✓ Verify backup user\
    \ exists and has permissions\n✓ Generate monitoring dashboard\n✓ Send alerts to\
    \ syslog\n\n**Dashboard format:**\n```\n╔════════════════════════════════════════╗\n\
    ║    Backup System Health Dashboard      ║\n╚════════════════════════════════════════╝\n\
    \nSystem Status: ✓ HEALTHY / ✗ WARNING / ✗✗ CRITICAL\n\nDisk Space:\n  /var/backups:\
    \ XX% used (XXX/XXX GB) [✓]\n\nLast Backups:\n  Full: 3 hours ago [✓]\n  Incremental:\
    \ 45 minutes ago [✓]\n  Logs: 15 minutes ago [✓]\n\nRecent Operations:\n  Last\
    \ 24h: 5 full, 20 incremental, 24 log compressions\n  Success rate: 100% (45/45)\n\
    \  Failed: 0\n\nStorage Trends:\n  Total backup size: XX.X GB\n  Growth rate:\
    \ +X.X GB/day\n  Estimated full: XX days\n\nCron Status: active [✓]\nBackup User:\
    \ backupuser [✓]\nPermissions: correct [✓]\n\nAlerts:\n  [YYYY-MM-DD HH:MM:SS]\
    \ WARNING: Disk usage 85%\n```\n\n**Alert thresholds:**\n- CRITICAL: Disk > 90%,\
    \ backup age > 48h, failures > 0\n- WARNING: Disk > 80%, backup age > 25h\n- INFO:\
    \ Normal operation\n\n**Success criteria:**\n- Script executable\n- Checks all\
    \ health metrics\n- Generates formatted dashboard\n- Sends appropriate alerts\n\
    - Can be run manually or via cron\n\n**Test:**\nsudo -u backupuser /opt/backup-system/monitor.sh\n"
  hint: Check df for disk space, find for backup age, grep logs for errors
  validation:
    type: command-output
    command: test -x /opt/backup-system/monitor.sh && ls /opt/backup-system/monitor.sh
    matcher: contains
    expected: monitor.sh
- id: document-recovery
  title: Document Recovery Procedures
  description: "**Task: Create Recovery Documentation**\n\nCreate: /opt/backup-system/RECOVERY.md\n\
    \n**Requirements:**\n\nComprehensive recovery guide covering:\n\n1. **Full System\
    \ Restore**\n   - Step-by-step restoration from full backup\n   - Command examples\n\
    \   - Verification steps\n\n2. **Incremental Restore**\n   - How to restore full\
    \ + all incrementals\n   - Proper order of operations\n   - Handling missing incrementals\n\
    \n3. **Point-in-Time Recovery**\n   - Restore to specific date/time\n   - Which\
    \ backups to use\n   - How to verify timestamp\n\n4. **Selective File Restore**\n\
    \   - Extract single file from archive\n   - Extract directory\n   - Restore specific\
    \ file versions\n\n5. **Disaster Recovery**\n   - Complete server rebuild scenario\n\
    \   - What to restore first\n   - Dependency order\n   - Testing restored system\n\
    \n6. **Common Scenarios**\n   - Accidental deletion\n   - Corrupted files\n  \
    \ - Ransomware attack\n   - Hardware failure\n   - Data center disaster\n\n7.\
    \ **Recovery Scripts**\n   - Automated restore script\n   - Verification script\n\
    \   - Rollback procedures\n\n**Example documentation structure:**\n```markdown\n\
    # Backup Recovery Procedures\n\n## Quick Reference\n\n| Scenario | Commands |\
    \ Time |\n|----------|----------|------|\n| Single file | tar -xzf backup.tar.gz\
    \ path/to/file | 1 min |\n| Full restore | ./restore_full.sh | 15 min |\n| Point-in-time\
    \ | ./restore_to_date.sh 2026-01-09 | 20 min |\n\n## Full System Restore\n\n###\
    \ Prerequisites\n- Access to backup archives\n- Sufficient disk space\n- Root\
    \ access\n\n### Steps\n\n1. Identify latest full backup:\n   ```bash\n   ls -lt\
    \ /var/backups/archives/full_backup_*.tar.gz | head -1\n   ```\n\n2. Verify archive\
    \ integrity:\n   ```bash\n   tar -tzf full_backup_YYYYMMDD.tar.gz > /dev/null\n\
    \   sha256sum -c full_backup_YYYYMMDD.tar.gz.sha256\n   ```\n\n3. Stop application:\n\
    \   ```bash\n   systemctl stop application\n   ```\n\n4. Backup current state:\n\
    \   ```bash\n   mv /srv/application /srv/application.old\n   ```\n\n5. Restore\
    \ full backup:\n   ```bash\n   cd /\n   tar --listed-incremental=/dev/null \\\n\
    \       -xzf /var/backups/archives/full_backup_YYYYMMDD.tar.gz\n   ```\n\n6. Apply\
    \ incremental backups (in order):\n   ```bash\n   for incr in $(ls -t incr_backup_*.tar.gz);\
    \ do\n     tar --listed-incremental=/dev/null -xzf \"$incr\"\n   done\n   ```\n\
    \n7. Restore permissions:\n   ```bash\n   chown -R www-data:www-data /srv/application\n\
    \   chmod 600 /srv/application/config/*.conf\n   ```\n\n8. Verify restoration:\n\
    \   ```bash\n   diff -r /srv/application /srv/application.old\n   ```\n\n9. Test\
    \ application:\n   ```bash\n   systemctl start application\n   systemctl status\
    \ application\n   ```\n\n10. Verify functionality:\n    ```bash\n    curl http://localhost/health\n\
    \    ```\n\n## Point-in-Time Recovery\n[... detailed steps ...]\n\n## Testing\
    \ Recovery\n[... test procedures ...]\n```\n\n**Create restore script:** /opt/backup-system/restore.sh\n\
    \n**Success criteria:**\n- RECOVERY.md exists and is comprehensive\n- Covers all\
    \ major scenarios\n- Includes command examples\n- Has troubleshooting section\n\
    - Restore script functional\n"
  hint: Document all recovery scenarios with step-by-step commands
  validation:
    type: file-exists
    path: /opt/backup-system/RECOVERY.md
    matcher: exists
- id: test-recovery
  title: Test Recovery Procedures
  description: '**Task: Implement and Test Recovery**


    Create: /opt/backup-system/restore.sh


    **Requirements:**


    ✓ Accept parameters: --full, --incremental, --date YYYYMMDD, --file path

    ✓ Verify backup archives exist

    ✓ Check checksums before restoring

    ✓ Backup current state before overwriting

    ✓ Restore to alternate location for testing

    ✓ Verify restored data

    ✓ Log all restore operations

    ✓ Support dry-run mode (--dry-run)


    **Script usage:**

    ```bash

    # Full restore to alternate location

    ./restore.sh --full --date 20260109 --target /tmp/restore


    # Restore specific file

    ./restore.sh --file data/user_1.json --date 20260109 --target /tmp/restore


    # Dry run (show what would be restored)

    ./restore.sh --full --date 20260109 --dry-run


    # Incremental restore (full + all incrementals)

    ./restore.sh --incremental --date 20260109 --target /tmp/restore

    ```


    **Testing procedure:**


    1. Create test data:

    echo "Test data $(date)" > /srv/application/data/test_restore.txt


    2. Run full backup:

    sudo -u backupuser /opt/backup-system/full_backup.sh


    3. Modify test data:

    echo "Modified data $(date)" >> /srv/application/data/test_restore.txt


    4. Run incremental backup:

    sudo -u backupuser /opt/backup-system/incremental_backup.sh


    5. Delete test data:

    rm /srv/application/data/test_restore.txt


    6. Restore from backup:

    sudo -u backupuser /opt/backup-system/restore.sh --incremental --target /tmp/restore


    7. Verify restoration:

    diff /tmp/restore/srv/application/data/test_restore.txt <expected_content>


    8. Test selective restore:

    sudo -u backupuser /opt/backup-system/restore.sh --file srv/application/config/database.conf
    --target /tmp/restore


    9. Document results:

    cat /var/log/backup/restore.log


    **Success criteria:**

    - Restore script exists and is executable

    - Supports all required modes

    - Successfully restores full backup

    - Successfully restores incremental backup

    - Can restore individual files

    - Logs all operations

    - Verifies restored data


    **Create and test:**

    # Test dry-run mode

    sudo -u backupuser /opt/backup-system/restore.sh --full --dry-run


    # Test actual restore

    sudo -u backupuser /opt/backup-system/restore.sh --full --target /tmp/test_restore


    # Verify

    ls -la /tmp/test_restore/

    '
  hint: Create restore script with dry-run and verification support
  validation:
    type: command-output
    command: test -x /opt/backup-system/restore.sh && ls /opt/backup-system/restore.sh
    matcher: contains
    expected: restore.sh
completion:
  message: "\U0001F389 PRODUCTION BACKUP SYSTEM COMPLETE! \U0001F389\n\nOutstanding\
    \ work! You've built an enterprise-grade backup solution!\n\n**What You've Implemented:**\n\
    \n✓ Full backup system with parallel compression\n✓ Incremental backup for efficiency\n\
    ✓ Log compression automation\n✓ Automated cron scheduling\n✓ Comprehensive verification\
    \ system\n✓ Health monitoring and alerting\n✓ Complete recovery documentation\n\
    ✓ Tested restoration procedures\n\n**System Architecture:**\n\n```\n/opt/backup-system/\n\
    ├── full_backup.sh          → Daily full backups\n├── incremental_backup.sh  \
    \ → 6-hourly incremental\n├── compress_logs.sh        → Hourly log compression\n\
    ├── verify_backups.sh       → Daily verification\n├── monitor.sh             \
    \ → Health monitoring\n├── restore.sh              → Recovery automation\n└──\
    \ RECOVERY.md             → Documentation\n\n/var/backups/\n├── archives/    \
    \           → Backup storage\n│   ├── full_backup_*.tar.gz\n│   ├── incr_backup_*.tar.gz\n\
    │   └── logs_*.tar.bz2\n└── logs/                   → Operation logs\n\n/etc/cron.d/\n\
    └── backup-system           → Scheduled jobs\n```\n\n**Backup Schedule:**\n- 02:00\
    \ - Full backup (daily)\n- 02,08,14,20:00 - Incremental backups\n- Every hour\
    \ - Log compression\n- 03:00 - Verification (daily)\n\n**Retention Policy:**\n\
    - 7 full backups (1 week)\n- 28 incremental backups (~1 week)\n- 24 log archives\
    \ (1 day)\n\n**Professional Features:**\n\n✓ **Reliability:**\n  - Integrity verification\n\
    \  - Checksum validation\n  - Error handling\n  - Atomic operations\n\n✓ **Performance:**\n\
    \  - Parallel compression (pigz)\n  - Incremental backups\n  - Efficient exclusions\n\
    \  - Optimized scheduling\n\n✓ **Monitoring:**\n  - Health dashboard\n  - Disk\
    \ space tracking\n  - Backup age monitoring\n  - Success rate metrics\n\n✓ **Recovery:**\n\
    \  - Multiple restore modes\n  - Dry-run testing\n  - Point-in-time recovery\n\
    \  - Comprehensive documentation\n\n✓ **Security:**\n  - Dedicated backup user\n\
    \  - Secure permissions\n  - Audit logging\n  - Checksum verification\n\n**Key\
    \ Metrics You Should Monitor:**\n\n1. **Backup Success Rate:** Target 100%\n2.\
    \ **Backup Window:** Should complete in < 1 hour\n3. **Disk Usage:** Alert at\
    \ 80%, critical at 90%\n4. **Backup Age:** Alert if > 25 hours old\n5. **Verification\
    \ Rate:** 100% of archives verified\n6. **Recovery Time:** Test quarterly, target\
    \ < 30 min\n\n**Production Checklist:**\n\n☑ All scripts executable and tested\n\
    ☑ Cron jobs scheduled correctly\n☑ Logging configured and rotating\n☑ Monitoring\
    \ alerts to syslog\n☑ Recovery procedures documented\n☑ Restoration tested successfully\n\
    ☑ Permissions correctly set\n☑ Backup user configured\n☑ Retention policy implemented\n\
    ☑ Disk space monitoring active\n\n**Real-World Best Practices Applied:**\n\n✓\
    \ 3-2-1 Rule: 3 copies, 2 media, 1 offsite (implement offsite next!)\n✓ Verify\
    \ before delete: Always verify backups work\n✓ Test recovery: Regular restoration\
    \ drills\n✓ Automate everything: No manual intervention\n✓ Monitor proactively:\
    \ Alert before failure\n✓ Document thoroughly: Future you will thank you\n\n**Next\
    \ Steps for Production:**\n\n1. Implement offsite backups (rsync to remote)\n\
    2. Add encryption (gpg for sensitive data)\n3. Set up email alerts (not just syslog)\n\
    4. Create Grafana dashboard for metrics\n5. Implement backup rotation to cold\
    \ storage\n6. Schedule quarterly disaster recovery drills\n\n**Commands Mastered:**\n\
    \nBackup: tar, pigz, pbzip2, gzip, bzip2\nScheduling: cron, crontab, anacron\n\
    Verification: tar -t, sha256sum\nMonitoring: df, du, find, grep\nRecovery: tar\
    \ -x, restore procedures\n\nYou now have the skills to manage enterprise backup\
    \ systems!\n\nThis is production-ready code that could be deployed in a real environment!\n\
    \nEXCEPTIONAL WORK! \U0001F680\n"
  xp: 800
  unlocks:
  - linux/week11/shell-scripting-beginner
  - linux/week11/shell-scripting-intermediate
