mission:
  id: linux/scripting/shell-scripting-intermediate
  title: 'Shell Scripting: Control Flow and Functions'
  difficulty: intermediate
  description: 'Build on your shell scripting basics with control flow, functions,
    and error

    handling. Learn to write robust, maintainable scripts with proper structure.


    Take your bash scripting to the next level!

    '
  estimated_time: 40
  xp_reward: 350
  tags:
  - shell-scripting
  - bash
  - functions
  - control-flow
  - scripting
environment:
  setup:
  - apt-get update && apt-get install -y \
  - bash \
  - coreutils
  image: ubuntu:22.04
steps:
- id: if-else-conditions
  description: "**Advanced Conditionals**\n\n**If-elif-else:**\n```bash\nif [ condition\
    \ ]; then\n  # commands\nelif [ condition2 ]; then\n  # commands\nelse\n  # commands\n\
    fi\n```\n\n**Test operators:**\n```bash\n# File tests\n[ -f file ]   # File exists\
    \ and is regular file\n[ -d dir ]    # Directory exists\n[ -r file ]   # File\
    \ is readable\n[ -w file ]   # File is writable\n[ -x file ]   # File is executable\n\
    \n# String tests\n[ -z \"$var\" ] # String is empty\n[ -n \"$var\" ] # String\
    \ is not empty\n[ \"$a\" = \"$b\" ]  # Strings equal\n\n# Numeric tests\n[ $a\
    \ -eq $b ] # Equal\n[ $a -ne $b ] # Not equal\n[ $a -lt $b ] # Less than\n[ $a\
    \ -gt $b ] # Greater than\n```\n\n**Task:** Create conditional script.\n\n```bash\n\
    mkdir -p ~/shell_intermediate\ncd ~/shell_intermediate\n\ncat > check_file.sh\
    \ << 'EOF'\n#!/bin/bash\n# File checker script\n\nif [ $# -eq 0 ]; then\n  echo\
    \ \"Usage: $0 <filename>\"\n  exit 1\nfi\n\nfile=\"$1\"\n\nif [ ! -e \"$file\"\
    \ ]; then\n  echo \"Error: File '$file' does not exist\"\n  exit 1\nfi\n\nif [\
    \ -f \"$file\" ]; then\n  echo \"✓ Regular file\"\nelif [ -d \"$file\" ]; then\n\
    \  echo \"✓ Directory\"\nelse\n  echo \"✓ Special file\"\nfi\n\nif [ -r \"$file\"\
    \ ]; then\n  echo \"✓ Readable\"\nfi\n\nif [ -w \"$file\" ]; then\n  echo \"✓\
    \ Writable\"\nfi\n\nif [ -x \"$file\" ]; then\n  echo \"✓ Executable\"\nfi\nEOF\n\
    \nchmod +x check_file.sh\n\n# Test it\ntouch testfile.txt\necho \"Conditional\
    \ Script Output\" > conditionals.txt\necho \"==========================\" >> conditionals.txt\n\
    ./check_file.sh testfile.txt >> conditionals.txt\n\ncat conditionals.txt\n```\n"
  hint: 'Use [ ] for test conditions. Use -f for files, -d for directories, -z for

    empty strings. Always quote variables: "$var"

    '
  validation:
    type: file-exists
    path: ~/shell_intermediate/conditionals.txt
    matcher: exists
  title: '**Advanced Conditionals**'
- id: case-statements
  description: "**Case Statements**\n\nBetter than multiple if-elif for pattern matching:\n\
    \n```bash\ncase \"$variable\" in\n  pattern1)\n    commands\n    ;;\n  pattern2|pattern3)\n\
    \    commands\n    ;;\n  *)\n    default commands\n    ;;\nesac\n```\n\n**Task:**\
    \ Create case statement script.\n\n```bash\ncat > menu.sh << 'EOF'\n#!/bin/bash\n\
    # Menu system with case\n\necho \"Select operation:\"\necho \"1) List files\"\n\
    echo \"2) Show date\"\necho \"3) Show disk usage\"\necho \"4) Exit\"\nread -p\
    \ \"Choice: \" choice\n\ncase $choice in\n  1)\n    echo \"Files:\"\n    ls -l\n\
    \    ;;\n  2)\n    echo \"Current date:\"\n    date\n    ;;\n  3)\n    echo \"\
    Disk usage:\"\n    df -h .\n    ;;\n  4)\n    echo \"Goodbye!\"\n    exit 0\n\
    \    ;;\n  *)\n    echo \"Invalid choice\"\n    exit 1\n    ;;\nesac\nEOF\n\n\
    chmod +x menu.sh\n\necho \"Case Statement Demo\" > case_demo.txt\necho \"===================\"\
    \ >> case_demo.txt\necho \"Script created: menu.sh\" >> case_demo.txt\necho \"\
    Usage: ./menu.sh and select option\" >> case_demo.txt\n\ncat case_demo.txt\n```\n"
  hint: 'case is cleaner than multiple if-elif. Use | for multiple patterns, *

    for default. Always end each case with ;;

    '
  validation:
    type: file-exists
    path: ~/shell_intermediate/case_demo.txt
    matcher: exists
  title: '**Case Statements**'
- id: functions
  description: "**Functions in Bash**\n\n**Defining functions:**\n```bash\nfunction_name()\
    \ {\n  # Function body\n  # $1, $2, ... are function arguments\n  return 0  #\
    \ Optional return code\n}\n\n# Or\nfunction function_name {\n  # Function body\n\
    }\n```\n\n**Task:** Create script with functions.\n\n```bash\ncat > utils.sh <<\
    \ 'EOF'\n#!/bin/bash\n# Utility functions\n\n# Check if file exists\nfile_exists()\
    \ {\n  if [ -f \"$1\" ]; then\n    return 0\n  else\n    return 1\n  fi\n}\n\n\
    # Print with timestamp\nlog() {\n  echo \"[$(date '+%Y-%m-%d %H:%M:%S')] $*\"\n\
    }\n\n# Calculate average\naverage() {\n  local sum=0\n  local count=$#\n  for\
    \ num in \"$@\"; do\n    sum=$((sum + num))\n  done\n  echo $((sum / count))\n\
    }\n\n# Main script\nlog \"Starting script\"\n\nif file_exists \"testfile.txt\"\
    ; then\n  log \"File exists\"\nelse\n  log \"Creating test file\"\n  touch testfile.txt\n\
    fi\n\nresult=$(average 10 20 30 40)\nlog \"Average of 10,20,30,40 is: $result\"\
    \n\nlog \"Script complete\"\nEOF\n\nchmod +x utils.sh\n\necho \"Functions Output\"\
    \ > functions.txt\necho \"================\" >> functions.txt\n./utils.sh >> functions.txt\n\
    \ncat functions.txt\n```\n"
  hint: 'Functions make code reusable. Use $1, $2 for arguments. Use ''local'' for

    variables inside functions. Return values via echo or return code.

    '
  validation:
    type: file-exists
    path: ~/shell_intermediate/functions.txt
    matcher: exists
  title: '**Functions in Bash**'
- id: error-handling
  description: "**Error Handling**\n\n**Exit codes:**\n```bash\ncommand\nif [ $? -eq\
    \ 0 ]; then\n  echo \"Success\"\nelse\n  echo \"Failed\"\n  exit 1\nfi\n```\n\n\
    **Set options:**\n```bash\nset -e  # Exit on error\nset -u  # Exit on undefined\
    \ variable\nset -o pipefail  # Pipeline fails if any command fails\n```\n\n**Task:**\
    \ Create robust script.\n\n```bash\ncat > robust.sh << 'EOF'\n#!/bin/bash\n# Robust\
    \ script with error handling\n\nset -euo pipefail\n\n# Error handler\nerror_exit()\
    \ {\n  echo \"Error: $1\" >&2\n  exit 1\n}\n\n# Check dependencies\ncommand -v\
    \ date >/dev/null || error_exit \"date command not found\"\n\n# Validate arguments\n\
    if [ $# -lt 1 ]; then\n  error_exit \"Usage: $0 <filename>\"\nfi\n\nfilename=\"\
    $1\"\n\n# Check file\n[ -f \"$filename\" ] || error_exit \"File not found: $filename\"\
    \n\necho \"Processing $filename...\"\nwc -l \"$filename\" || error_exit \"Failed\
    \ to count lines\"\n\necho \"Success!\"\nEOF\n\nchmod +x robust.sh\n\ntouch datafile.txt\n\
    echo \"line 1\" >> datafile.txt\n\necho \"Error Handling Demo\" > error_demo.txt\n\
    echo \"===================\" >> error_demo.txt\n./robust.sh datafile.txt >> error_demo.txt\
    \ 2>&1\n\ncat error_demo.txt\n```\n"
  hint: 'Use ''set -e'' to exit on errors, ''set -u'' for undefined variables. Check

    exit codes with $?. Always validate inputs!

    '
  validation:
    type: file-exists
    path: ~/shell_intermediate/error_demo.txt
    matcher: exists
  title: '**Error Handling**'
- id: practical-script
  description: "**Practical Script: Backup Tool**\n\n**Task:** Build a complete backup\
    \ script.\n\n```bash\ncat > backup.sh << 'EOF'\n#!/bin/bash\n# Simple backup script\n\
    \nset -euo pipefail\n\n# Configuration\nBACKUP_DIR=\"$HOME/backups\"\nDATE=$(date\
    \ +%Y%m%d_%H%M%S)\n\n# Functions\nlog() {\n  echo \"[$(date '+%H:%M:%S')] $*\"\
    \n}\n\ncreate_backup() {\n  local source=\"$1\"\n  local backup_name=$(basename\
    \ \"$source\")_$DATE.tar.gz\n\n  log \"Backing up: $source\"\n\n  if [ ! -e \"\
    $source\" ]; then\n    log \"Error: Source not found\"\n    return 1\n  fi\n\n\
    \  tar -czf \"$BACKUP_DIR/$backup_name\" \"$source\" 2>/dev/null\n\n  if [ $?\
    \ -eq 0 ]; then\n    log \"Success: $backup_name\"\n    return 0\n  else\n   \
    \ log \"Failed to create backup\"\n    return 1\n  fi\n}\n\n# Main\nlog \"Starting\
    \ backup process\"\n\nmkdir -p \"$BACKUP_DIR\"\n\nif [ $# -eq 0 ]; then\n  log\
    \ \"Usage: $0 <file_or_directory>\"\n  exit 1\nfi\n\nfor item in \"$@\"; do\n\
    \  create_backup \"$item\"\ndone\n\nlog \"Backup complete\"\nlog \"Backups stored\
    \ in: $BACKUP_DIR\"\nEOF\n\nchmod +x backup.sh\n\n# Test it\nmkdir -p test_data\n\
    echo \"important\" > test_data/file.txt\n\necho \"Backup Script Demo\" > backup_demo.txt\n\
    echo \"==================\" >> backup_demo.txt\n./backup.sh test_data >> backup_demo.txt\
    \ 2>&1\n\necho \"\" >> backup_demo.txt\necho \"Backups created:\" >> backup_demo.txt\n\
    ls -lh ~/backups/ >> backup_demo.txt 2>&1 || echo \"No backups yet\" >> backup_demo.txt\n\
    \ncat backup_demo.txt\n```\n\n**Congratulations!** You've mastered intermediate\
    \ shell scripting!\n\n**You learned:**\n- Advanced conditionals (if-elif-else)\n\
    - Case statements for pattern matching\n- Functions for code reuse\n- Error handling\
    \ and validation\n- Building practical scripts\n\n**Best practices:**\n- Use set\
    \ -euo pipefail\n- Validate all inputs\n- Create functions for reusable code\n\
    - Add logging for visibility\n- Handle errors gracefully\n\nYou can now write\
    \ maintainable, robust scripts!\n"
  hint: 'Structure scripts: configuration, functions, main logic. Use functions

    for reusable code. Always validate inputs and handle errors.

    '
  validation:
    type: file-exists
    path: ~/shell_intermediate/backup_demo.txt
    matcher: exists
  title: '**Practical Script: Backup Tool**'
completion:
  message: Congratulations! You've completed this intermediate mission.
  xp: 300
  unlocks: []
