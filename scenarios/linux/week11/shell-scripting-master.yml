mission:
  id: "linux/week11/shell-scripting-master"
  title: "Master Challenge: Build a System Monitoring Tool"
  difficulty: master
  description: "Create a professional-grade shell script that monitors system resources, logs events, and sends alerts"
  estimated_time: 90
  tags:
    - linux
    - scripting
    - advanced
    - master
    - week11
    - week12
    - cst8207

environment:
  image: "ubuntu:22.04"
  workdir: "/home/learner"
  setup:
    - "mkdir -p /home/learner/scripts"
    - "mkdir -p /home/learner/logs"
    - "mkdir -p /var/log/monitor"
    - "apt-get update -qq && apt-get install -y -qq bc"
    # Create test files for monitoring
    - "dd if=/dev/zero of=/tmp/largefile bs=1M count=50 2>/dev/null"
    - "mkdir -p /home/learner/test_dir"
    - "touch /home/learner/test_dir/file{1..20}.txt"

steps:
  - id: "script-header-and-setup"
    title: "Create Professional Script Structure"
    description: |
      **MASTER-LEVEL CHALLENGE**

      Build a complete system monitoring script called 'sysmonitor.sh'
      with professional structure.

      **Requirements:**

      1. **Script Header:**
         ```bash
         #!/bin/bash
         #
         # sysmonitor.sh - System Resource Monitor
         # Author: Your Name
         # Description: Monitors CPU, Memory, Disk usage and logs alerts
         # Usage: ./sysmonitor.sh [options]
         #
         ```

      2. **Global Variables:**
         - LOG_FILE="/var/log/monitor/system.log"
         - ERROR_LOG="/var/log/monitor/error.log"
         - ALERT_THRESHOLD_CPU=80
         - ALERT_THRESHOLD_MEM=75
         - ALERT_THRESHOLD_DISK=90
         - TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

      3. **Color Codes for Output:**
         - RED='\033[0;31m'
         - GREEN='\033[0;32m'
         - YELLOW='\033[1;33m'
         - NC='\033[0m' # No Color

      Create the initial structure in ~/scripts/sysmonitor.sh

      **This is a master challenge - minimal guidance provided!**
    hint: "Create script with shebang, comments, variables, and color codes"
    validation:
      type: "command-output"
      command: "test -f /home/learner/scripts/sysmonitor.sh && head -n 1 /home/learner/scripts/sysmonitor.sh"
      matcher: "contains"
      expected: "#!/bin/bash"

  - id: "logging-functions"
    title: "Implement Robust Logging System"
    description: |
      **Logging Requirements:**

      Create logging functions with different severity levels:

      ```bash
      log_info() {
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [INFO] $*" | tee -a "$LOG_FILE"
      }

      log_warning() {
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [WARNING] $*" | tee -a "$LOG_FILE" >&2
      }

      log_error() {
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] [ERROR] $*" | tee -a "$ERROR_LOG" >&2
      }
      ```

      **Features:**
      - Timestamps on every log entry
      - Different severity levels
      - Write to both console and log file
      - Errors go to stderr AND error log

      Add these functions to your script.
    hint: "Use tee to write to both console and file, >&2 for stderr"
    validation:
      type: "command-output"
      command: |
        cat > /tmp/test_log.sh << 'EOF'
        #!/bin/bash
        log_info() { echo "[INFO] $*"; }
        log_info "Test message"
        EOF
        bash /tmp/test_log.sh
      matcher: "contains"
      expected: "[INFO] Test message"

  - id: "cpu-monitoring"
    title: "Implement CPU Usage Monitoring"
    description: |
      **CPU Monitoring Function:**

      Create a function that:
      1. Gets current CPU usage percentage
      2. Compares against threshold (80%)
      3. Logs warning if exceeded
      4. Returns the CPU percentage

      ```bash
      check_cpu() {
        # Get CPU usage (this is a simplified approach)
        local cpu_usage=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\\([0-9.]*\\)%* id.*/\\1/" | awk '{print 100 - $1}')

        # Alternative using /proc/stat for accuracy
        cpu_usage=$(grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print int(usage)}')

        log_info "CPU Usage: ${cpu_usage}%"

        if (( $(echo "$cpu_usage > $ALERT_THRESHOLD_CPU" | bc -l) )); then
          log_warning "CPU usage HIGH: ${cpu_usage}% (threshold: ${ALERT_THRESHOLD_CPU}%)"
          return 1
        fi

        return 0
      }
      ```

      **Challenge:**
      - Handle systems where bc might not be available
      - Parse complex output correctly
      - Use proper integer comparison

      Implement this function in your script.
    hint: "Use /proc/stat for CPU info, awk for calculation, bc for decimal comparison"
    validation:
      type: "command-output"
      command: "grep 'cpu ' /proc/stat | awk '{print \"CPU:\", int(($2+$4)*100/($2+$4+$5)), \"%\"}'"
      matcher: "contains"
      expected: "CPU:"

  - id: "memory-monitoring"
    title: "Implement Memory Usage Monitoring"
    description: |
      **Memory Monitoring Function:**

      Create a function to monitor RAM usage:

      ```bash
      check_memory() {
        # Get memory info from /proc/meminfo
        local mem_total=$(grep MemTotal /proc/meminfo | awk '{print $2}')
        local mem_available=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
        local mem_used=$((mem_total - mem_available))
        local mem_percent=$((mem_used * 100 / mem_total))

        log_info "Memory Usage: ${mem_percent}% (${mem_used}KB / ${mem_total}KB)"

        if [ "$mem_percent" -gt "$ALERT_THRESHOLD_MEM" ]; then
          log_warning "Memory usage HIGH: ${mem_percent}% (threshold: ${ALERT_THRESHOLD_MEM}%)"

          # Show top 5 memory-consuming processes
          log_info "Top 5 memory consumers:"
          ps aux --sort=-%mem | head -n 6 | tail -n 5 | awk '{print $11, $4"%"}' | while read proc mem; do
            log_info "  $proc: $mem"
          done

          return 1
        fi

        return 0
      }
      ```

      **Advanced Requirements:**
      - Parse /proc/meminfo correctly
      - Calculate percentages accurately
      - List top memory consumers on high usage
      - Use proper integer arithmetic

      Add this function to your script.
    hint: "Use /proc/meminfo for data, ps aux for process list, awk for formatting"
    validation:
      type: "command-output"
      command: "grep MemTotal /proc/meminfo | awk '{print \"Memory:\", $2, \"KB\"}'"
      matcher: "contains"
      expected: "Memory:"

  - id: "disk-monitoring"
    title: "Implement Disk Space Monitoring"
    description: |
      **Disk Monitoring Function:**

      Monitor disk usage for all mounted filesystems:

      ```bash
      check_disk() {
        log_info "Checking disk usage..."

        local alert_triggered=0

        # Check each filesystem
        df -h | grep -vE '^Filesystem|tmpfs|cdrom|loop' | while read filesystem size used avail percent mountpoint; do
          # Remove % symbol
          usage="${percent%%%}"

          if [ "$usage" -gt "$ALERT_THRESHOLD_DISK" ]; then
            log_warning "Disk usage HIGH on $mountpoint: $percent (threshold: ${ALERT_THRESHOLD_DISK}%)"
            alert_triggered=1

            # Show largest directories
            log_info "Largest directories in $mountpoint:"
            du -sh "$mountpoint"/* 2>/dev/null | sort -rh | head -n 5 | while read size dir; do
              log_info "  $size  $dir"
            done
          else
            log_info "Disk $mountpoint: $percent used"
          fi
        done

        return $alert_triggered
      }
      ```

      **Features:**
      - Check all mountpoints except special filesystems
      - Parse df output correctly
      - Handle percentage symbol removal
      - Show largest directories on alert
      - Robust error handling (2>/dev/null)

      Implement this comprehensive disk checking.
    hint: "Use df for disk info, du for directory sizes, sort -rh for human-readable sort"
    validation:
      type: "command-output"
      command: "df -h | grep -vE '^Filesystem|tmpfs' | head -n 1 | awk '{print $1, $5}'"
      matcher: "contains"
      expected: "/"

  - id: "command-line-argument-parsing"
    title: "Implement Argument Parsing and Help"
    description: |
      **Command-Line Interface:**

      Your script should support these options:

      ```bash
      usage() {
        cat << EOF
      Usage: $0 [OPTIONS]

      System Resource Monitor - Checks CPU, Memory, and Disk usage

      OPTIONS:
        -h, --help              Show this help message
        -v, --verbose           Verbose output
        -c, --cpu-only          Check CPU only
        -m, --mem-only          Check memory only
        -d, --disk-only         Check disk only
        -t, --threshold NUM     Set custom alert threshold (%)
        -l, --log-file PATH     Custom log file location
        -i, --interval SEC      Monitor continuously every SEC seconds

      EXAMPLES:
        $0                      # Run all checks once
        $0 --cpu-only          # Check CPU only
        $0 -i 60               # Monitor every 60 seconds
        $0 -t 90 --verbose     # Custom threshold with verbose output

      EOF
        exit 0
      }

      # Parse arguments
      VERBOSE=false
      CHECK_CPU=true
      CHECK_MEM=true
      CHECK_DISK=true
      INTERVAL=0
      CUSTOM_THRESHOLD=0

      while [[ $# -gt 0 ]]; do
        case $1 in
          -h|--help)
            usage
            ;;
          -v|--verbose)
            VERBOSE=true
            shift
            ;;
          -c|--cpu-only)
            CHECK_MEM=false
            CHECK_DISK=false
            shift
            ;;
          -m|--mem-only)
            CHECK_CPU=false
            CHECK_DISK=false
            shift
            ;;
          -d|--disk-only)
            CHECK_CPU=false
            CHECK_MEM=false
            shift
            ;;
          -t|--threshold)
            CUSTOM_THRESHOLD="$2"
            shift 2
            ;;
          -i|--interval)
            INTERVAL="$2"
            shift 2
            ;;
          -l|--log-file)
            LOG_FILE="$2"
            shift 2
            ;;
          *)
            echo "Unknown option: $1"
            usage
            ;;
        esac
      done
      ```

      **Advanced Parsing Features:**
      - Short and long options
      - Options with values (-t 90)
      - Boolean flags
      - Help documentation
      - Input validation

      Implement the full argument parsing system.
    hint: "Use case statement for parsing, shift to consume arguments, provide help"
    validation:
      type: "command-output"
      command: |
        cat > /tmp/test_args.sh << 'EOF'
        #!/bin/bash
        while [[ $# -gt 0 ]]; do
          case $1 in
            -h) echo "Help requested"; exit 0;;
            *) shift;;
          esac
        done
        EOF
        bash /tmp/test_args.sh -h
      matcher: "contains"
      expected: "Help requested"

  - id: "main-execution-loop"
    title: "Implement Main Execution Logic"
    description: |
      **Main Execution Function:**

      Tie everything together with proper flow control:

      ```bash
      main() {
        log_info "=========================================="
        log_info "System Monitor Started"
        log_info "=========================================="

        local exit_code=0

        # Run checks based on flags
        if [ "$CHECK_CPU" = true ]; then
          check_cpu || exit_code=$?
        fi

        if [ "$CHECK_MEM" = true ]; then
          check_memory || exit_code=$?
        fi

        if [ "$CHECK_DISK" = true ]; then
          check_disk || exit_code=$?
        fi

        # Summary
        if [ $exit_code -eq 0 ]; then
          echo -e "${GREEN}‚úì All checks passed${NC}"
          log_info "All checks passed successfully"
        else
          echo -e "${RED}‚úó Some checks triggered alerts${NC}"
          log_warning "Checks completed with warnings"
        fi

        log_info "=========================================="
        return $exit_code
      }

      # Continuous monitoring loop
      if [ "$INTERVAL" -gt 0 ]; then
        log_info "Starting continuous monitoring (interval: ${INTERVAL}s)"
        log_info "Press Ctrl+C to stop"

        trap 'log_info "Monitoring stopped by user"; exit 0' INT TERM

        while true; do
          main
          sleep "$INTERVAL"
        done
      else
        # Single run
        main
        exit $?
      fi
      ```

      **Advanced Features:**
      - Conditional execution based on flags
      - Exit code handling
      - Signal trapping for graceful shutdown
      - Continuous monitoring mode
      - Color-coded output
      - Comprehensive logging

      Complete the main execution logic.
    hint: "Use trap for signal handling, test flags before running checks, handle exit codes"
    validation:
      type: "command-output"
      command: |
        cat > /tmp/test_main.sh << 'EOF'
        #!/bin/bash
        main() {
          echo "Main executed"
          return 0
        }
        main
        EOF
        bash /tmp/test_main.sh
      matcher: "contains"
      expected: "Main executed"

  - id: "error-handling-and-validation"
    title: "Add Robust Error Handling"
    description: |
      **Error Handling Requirements:**

      Add these safety checks at the start of your script:

      ```bash
      # Check if running as root (optional but recommended for system monitoring)
      check_permissions() {
        if [ "$EUID" -ne 0 ] && [ ! -w "/var/log/monitor" ]; then
          log_warning "Not running as root. Some features may be limited."
          LOG_FILE="$HOME/system-monitor.log"
          ERROR_LOG="$HOME/system-monitor-error.log"
          log_info "Using alternative log location: $LOG_FILE"
        fi
      }

      # Validate dependencies
      check_dependencies() {
        local missing_deps=()

        for cmd in awk grep df ps top; do
          if ! command -v "$cmd" &> /dev/null; then
            missing_deps+=("$cmd")
          fi
        done

        if [ ${#missing_deps[@]} -gt 0 ]; then
          log_error "Missing required commands: ${missing_deps[*]}"
          exit 1
        fi
      }

      # Create log directories
      ensure_log_dir() {
        local log_dir=$(dirname "$LOG_FILE")
        if [ ! -d "$log_dir" ]; then
          mkdir -p "$log_dir" 2>/dev/null || {
            log_error "Cannot create log directory: $log_dir"
            LOG_FILE="$HOME/system-monitor.log"
            ERROR_LOG="$HOME/system-monitor-error.log"
          }
        fi
      }

      # Input validation
      validate_threshold() {
        if [ "$CUSTOM_THRESHOLD" -gt 0 ]; then
          if [ "$CUSTOM_THRESHOLD" -lt 1 ] || [ "$CUSTOM_THRESHOLD" -gt 100 ]; then
            log_error "Threshold must be between 1 and 100"
            exit 1
          fi
          ALERT_THRESHOLD_CPU=$CUSTOM_THRESHOLD
          ALERT_THRESHOLD_MEM=$CUSTOM_THRESHOLD
          ALERT_THRESHOLD_DISK=$CUSTOM_THRESHOLD
        fi
      }

      # Run all checks before main execution
      check_permissions
      check_dependencies
      ensure_log_dir
      validate_threshold
      ```

      **Error Handling Best Practices:**
      - Check permissions early
      - Validate all dependencies
      - Provide fallbacks for failures
      - Validate user input
      - Create directories safely
      - Meaningful error messages

      Add comprehensive error handling to your script.
    hint: "Check command existence with 'command -v', validate numeric ranges, handle directory creation"
    validation:
      type: "command-output"
      command: "command -v awk && echo 'Command check works'"
      matcher: "contains"
      expected: "Command check works"

  - id: "final-testing"
    title: "Test Complete System"
    description: |
      **Final Integration Test:**

      Your complete system monitor should now:

      ‚úì Accept command-line arguments
      ‚úì Parse options correctly
      ‚úì Check dependencies
      ‚úì Handle permissions gracefully
      ‚úì Monitor CPU usage
      ‚úì Monitor memory usage
      ‚úì Monitor disk usage
      ‚úì Log events with timestamps
      ‚úì Trigger alerts on thresholds
      ‚úì Support continuous monitoring
      ‚úì Handle signals gracefully
      ‚úì Provide colored output
      ‚úì Exit with appropriate codes

      **Test Commands:**

      1. Basic run:
         ```bash
         chmod +x ~/scripts/sysmonitor.sh
         ~/scripts/sysmonitor.sh
         ```

      2. Show help:
         ```bash
         ~/scripts/sysmonitor.sh --help
         ```

      3. Check CPU only:
         ```bash
         ~/scripts/sysmonitor.sh --cpu-only
         ```

      4. Custom threshold:
         ```bash
         ~/scripts/sysmonitor.sh -t 50 --verbose
         ```

      5. Verify logs created:
         ```bash
         ls -la ~/logs/
         cat ~/logs/system.log
         ```

      **Debugging Tips:**
      - Add set -x for debugging
      - Use set -e to exit on errors
      - Test each function individually
      - Check log files for errors
      - Verify exit codes: echo $?

      **This is a master-level challenge - you must integrate all concepts!**
    hint: |
      Integration checklist:
      ‚òê All functions defined
      ‚òê Argument parsing works
      ‚òê Dependencies checked
      ‚òê Logs being written
      ‚òê CPU check functional
      ‚òê Memory check functional
      ‚òê Disk check functional
      ‚òê Colors work
      ‚òê Help displays
      ‚òê Exit codes correct
    validation:
      type: "command-output"
      command: |
        # Create a complete working version for validation
        cat > /tmp/sysmonitor_test.sh << 'COMPLETE_SCRIPT'
        #!/bin/bash
        LOG_FILE="/tmp/system.log"
        log_info() { echo "[INFO] $*" >> "$LOG_FILE"; echo "[INFO] $*"; }
        check_cpu() { log_info "CPU check passed"; return 0; }
        check_memory() { log_info "Memory check passed"; return 0; }
        check_disk() { log_info "Disk check passed"; return 0; }
        main() {
          log_info "System Monitor Started"
          check_cpu && check_memory && check_disk
          log_info "All checks completed"
          return 0
        }
        main
        COMPLETE_SCRIPT
        chmod +x /tmp/sysmonitor_test.sh
        /tmp/sysmonitor_test.sh && echo "SUCCESS"
      matcher: "contains"
      expected: "SUCCESS"

completion:
  message: |
    üèÜ MASTER CHALLENGE CONQUERED! üèÜ

    You've built a PRODUCTION-GRADE system monitoring tool from scratch!

    **What You've Accomplished:**

    ‚úì Professional script structure with documentation
    ‚úì Multi-level logging system (INFO, WARNING, ERROR)
    ‚úì CPU monitoring with /proc/stat parsing
    ‚úì Memory monitoring with detailed analysis
    ‚úì Disk space monitoring with directory analysis
    ‚úì Comprehensive argument parsing (short & long options)
    ‚úì Error handling and input validation
    ‚úì Dependency checking
    ‚úì Continuous monitoring mode
    ‚úì Signal handling (Ctrl+C gracefully)
    ‚úì Color-coded output
    ‚úì Log file management
    ‚úì Exit code handling
    ‚úì Professional help documentation

    **Advanced Techniques Mastered:**

    - Complex function design
    - /proc filesystem parsing
    - awk for data processing
    - bc for floating-point math
    - Process management (ps, top)
    - Signal trapping
    - Case statement parsing
    - Array handling
    - Conditional execution
    - I/O redirection (tee, stderr)
    - File system navigation
    - String manipulation
    - Integer arithmetic
    - Command substitution
    - Exit code propagation

    **Real-World Applications:**

    This script can be used in production to:
    - Monitor server health
    - Trigger automated responses
    - Send alerts to administrators
    - Log system performance
    - Detect resource exhaustion
    - Schedule via cron for continuous monitoring

    **Skills Demonstrated:**

    You've proven mastery of:
    ‚òë Shell scripting fundamentals (CLR 5)
    ‚òë System administration (CLR 4)
    ‚òë Problem decomposition (CLR 6)
    ‚òë Error handling (CLR 5)
    ‚òë Documentation (CLR 6)
    ‚òë Testing and validation (CLR 6)

    You're now ready for professional DevOps work!

    **Next Steps:**
    - Add email alerting
    - Integrate with monitoring systems (Prometheus, Grafana)
    - Add network monitoring
    - Create web dashboard
    - Package as systemd service

    CONGRATULATIONS ON COMPLETING THIS MASTER-LEVEL CHALLENGE!
  xp: 1500
  unlocks:
    - "linux/week13/regex-text-processing-advanced"
    - "linux/week14/ssh-security-expert"
