mission:
  id: linux/week11/shell-scripting-master
  title: 'Master Challenge: Build a System Monitoring Tool'
  difficulty: advanced
  description: Create a professional-grade shell script that monitors system resources,
    logs events, and sends alerts
  estimated_time: 90
  tags:
  - linux
  - scripting
  - advanced
  - master
  - week11
  - week12
  - cst8207
environment:
  image: ubuntu:22.04
  workdir: /home/learner
  setup:
  - mkdir -p /home/learner/scripts
  - mkdir -p /home/learner/logs
  - mkdir -p /var/log/monitor
  - apt-get update -qq && apt-get install -y -qq bc
  - dd if=/dev/zero of=/tmp/largefile bs=1M count=50 2>/dev/null
  - mkdir -p /home/learner/test_dir
  - touch /home/learner/test_dir/file{1..20}.txt
steps:
- id: script-header-and-setup
  title: Create Professional Script Structure
  description: "**MASTER-LEVEL CHALLENGE**\n\nBuild a complete system monitoring script\
    \ called 'sysmonitor.sh'\nwith professional structure.\n\n**Requirements:**\n\n\
    1. **Script Header:**\n   ```bash\n   #!/bin/bash\n   #\n   # sysmonitor.sh -\
    \ System Resource Monitor\n   # Author: Your Name\n   # Description: Monitors\
    \ CPU, Memory, Disk usage and logs alerts\n   # Usage: ./sysmonitor.sh [options]\n\
    \   #\n   ```\n\n2. **Global Variables:**\n   - LOG_FILE=\"/var/log/monitor/system.log\"\
    \n   - ERROR_LOG=\"/var/log/monitor/error.log\"\n   - ALERT_THRESHOLD_CPU=80\n\
    \   - ALERT_THRESHOLD_MEM=75\n   - ALERT_THRESHOLD_DISK=90\n   - TIMESTAMP=$(date\
    \ '+%Y-%m-%d %H:%M:%S')\n\n3. **Color Codes for Output:**\n   - RED='\\033[0;31m'\n\
    \   - GREEN='\\033[0;32m'\n   - YELLOW='\\033[1;33m'\n   - NC='\\033[0m' # No\
    \ Color\n\nCreate the initial structure in ~/scripts/sysmonitor.sh\n\n**This is\
    \ a master challenge - minimal guidance provided!**\n"
  hint: Create script with shebang, comments, variables, and color codes
  validation:
    type: command-output
    command: test -f /home/learner/scripts/sysmonitor.sh && head -n 1 /home/learner/scripts/sysmonitor.sh
    matcher: contains
    expected: '#!/bin/bash'
- id: logging-functions
  title: Implement Robust Logging System
  description: "**Logging Requirements:**\n\nCreate logging functions with different\
    \ severity levels:\n\n```bash\nlog_info() {\n  echo \"[$(date '+%Y-%m-%d %H:%M:%S')]\
    \ [INFO] $*\" | tee -a \"$LOG_FILE\"\n}\n\nlog_warning() {\n  echo \"[$(date '+%Y-%m-%d\
    \ %H:%M:%S')] [WARNING] $*\" | tee -a \"$LOG_FILE\" >&2\n}\n\nlog_error() {\n\
    \  echo \"[$(date '+%Y-%m-%d %H:%M:%S')] [ERROR] $*\" | tee -a \"$ERROR_LOG\"\
    \ >&2\n}\n```\n\n**Features:**\n- Timestamps on every log entry\n- Different severity\
    \ levels\n- Write to both console and log file\n- Errors go to stderr AND error\
    \ log\n\nAdd these functions to your script.\n"
  hint: Use tee to write to both console and file, >&2 for stderr
  validation:
    type: command-output
    command: 'cat > /tmp/test_log.sh << ''EOF''

      #!/bin/bash

      log_info() { echo "[INFO] $*"; }

      log_info "Test message"

      EOF

      bash /tmp/test_log.sh

      '
    matcher: contains
    expected: '[INFO] Test message'
- id: cpu-monitoring
  title: Implement CPU Usage Monitoring
  description: "**CPU Monitoring Function:**\n\nCreate a function that:\n1. Gets current\
    \ CPU usage percentage\n2. Compares against threshold (80%)\n3. Logs warning if\
    \ exceeded\n4. Returns the CPU percentage\n\n```bash\ncheck_cpu() {\n  # Get CPU\
    \ usage (this is a simplified approach)\n  local cpu_usage=$(top -bn1 | grep \"\
    Cpu(s)\" | sed \"s/.*, *\\\\([0-9.]*\\\\)%* id.*/\\\\1/\" | awk '{print 100 -\
    \ $1}')\n\n  # Alternative using /proc/stat for accuracy\n  cpu_usage=$(grep 'cpu\
    \ ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print int(usage)}')\n\
    \n  log_info \"CPU Usage: ${cpu_usage}%\"\n\n  if (( $(echo \"$cpu_usage > $ALERT_THRESHOLD_CPU\"\
    \ | bc -l) )); then\n    log_warning \"CPU usage HIGH: ${cpu_usage}% (threshold:\
    \ ${ALERT_THRESHOLD_CPU}%)\"\n    return 1\n  fi\n\n  return 0\n}\n```\n\n**Challenge:**\n\
    - Handle systems where bc might not be available\n- Parse complex output correctly\n\
    - Use proper integer comparison\n\nImplement this function in your script.\n"
  hint: Use /proc/stat for CPU info, awk for calculation, bc for decimal comparison
  validation:
    type: command-output
    command: grep 'cpu ' /proc/stat | awk '{print "CPU:", int(($2+$4)*100/($2+$4+$5)),
      "%"}'
    matcher: contains
    expected: 'CPU:'
- id: memory-monitoring
  title: Implement Memory Usage Monitoring
  description: "**Memory Monitoring Function:**\n\nCreate a function to monitor RAM\
    \ usage:\n\n```bash\ncheck_memory() {\n  # Get memory info from /proc/meminfo\n\
    \  local mem_total=$(grep MemTotal /proc/meminfo | awk '{print $2}')\n  local\
    \ mem_available=$(grep MemAvailable /proc/meminfo | awk '{print $2}')\n  local\
    \ mem_used=$((mem_total - mem_available))\n  local mem_percent=$((mem_used * 100\
    \ / mem_total))\n\n  log_info \"Memory Usage: ${mem_percent}% (${mem_used}KB /\
    \ ${mem_total}KB)\"\n\n  if [ \"$mem_percent\" -gt \"$ALERT_THRESHOLD_MEM\" ];\
    \ then\n    log_warning \"Memory usage HIGH: ${mem_percent}% (threshold: ${ALERT_THRESHOLD_MEM}%)\"\
    \n\n    # Show top 5 memory-consuming processes\n    log_info \"Top 5 memory consumers:\"\
    \n    ps aux --sort=-%mem | head -n 6 | tail -n 5 | awk '{print $11, $4\"%\"}'\
    \ | while read proc mem; do\n      log_info \"  $proc: $mem\"\n    done\n\n  \
    \  return 1\n  fi\n\n  return 0\n}\n```\n\n**Advanced Requirements:**\n- Parse\
    \ /proc/meminfo correctly\n- Calculate percentages accurately\n- List top memory\
    \ consumers on high usage\n- Use proper integer arithmetic\n\nAdd this function\
    \ to your script.\n"
  hint: Use /proc/meminfo for data, ps aux for process list, awk for formatting
  validation:
    type: command-output
    command: grep MemTotal /proc/meminfo | awk '{print "Memory:", $2, "KB"}'
    matcher: contains
    expected: 'Memory:'
- id: disk-monitoring
  title: Implement Disk Space Monitoring
  description: "**Disk Monitoring Function:**\n\nMonitor disk usage for all mounted\
    \ filesystems:\n\n```bash\ncheck_disk() {\n  log_info \"Checking disk usage...\"\
    \n\n  local alert_triggered=0\n\n  # Check each filesystem\n  df -h | grep -vE\
    \ '^Filesystem|tmpfs|cdrom|loop' | while read filesystem size used avail percent\
    \ mountpoint; do\n    # Remove % symbol\n    usage=\"${percent%%%}\"\n\n    if\
    \ [ \"$usage\" -gt \"$ALERT_THRESHOLD_DISK\" ]; then\n      log_warning \"Disk\
    \ usage HIGH on $mountpoint: $percent (threshold: ${ALERT_THRESHOLD_DISK}%)\"\n\
    \      alert_triggered=1\n\n      # Show largest directories\n      log_info \"\
    Largest directories in $mountpoint:\"\n      du -sh \"$mountpoint\"/* 2>/dev/null\
    \ | sort -rh | head -n 5 | while read size dir; do\n        log_info \"  $size\
    \  $dir\"\n      done\n    else\n      log_info \"Disk $mountpoint: $percent used\"\
    \n    fi\n  done\n\n  return $alert_triggered\n}\n```\n\n**Features:**\n- Check\
    \ all mountpoints except special filesystems\n- Parse df output correctly\n- Handle\
    \ percentage symbol removal\n- Show largest directories on alert\n- Robust error\
    \ handling (2>/dev/null)\n\nImplement this comprehensive disk checking.\n"
  hint: Use df for disk info, du for directory sizes, sort -rh for human-readable
    sort
  validation:
    type: command-output
    command: df -h | grep -vE '^Filesystem|tmpfs' | head -n 1 | awk '{print $1, $5}'
    matcher: contains
    expected: /
- id: command-line-argument-parsing
  title: Implement Argument Parsing and Help
  description: "**Command-Line Interface:**\n\nYour script should support these options:\n\
    \n```bash\nusage() {\n  cat << EOF\nUsage: $0 [OPTIONS]\n\nSystem Resource Monitor\
    \ - Checks CPU, Memory, and Disk usage\n\nOPTIONS:\n  -h, --help             \
    \ Show this help message\n  -v, --verbose           Verbose output\n  -c, --cpu-only\
    \          Check CPU only\n  -m, --mem-only          Check memory only\n  -d,\
    \ --disk-only         Check disk only\n  -t, --threshold NUM     Set custom alert\
    \ threshold (%)\n  -l, --log-file PATH     Custom log file location\n  -i, --interval\
    \ SEC      Monitor continuously every SEC seconds\n\nEXAMPLES:\n  $0         \
    \             # Run all checks once\n  $0 --cpu-only          # Check CPU only\n\
    \  $0 -i 60               # Monitor every 60 seconds\n  $0 -t 90 --verbose   \
    \  # Custom threshold with verbose output\n\nEOF\n  exit 0\n}\n\n# Parse arguments\n\
    VERBOSE=false\nCHECK_CPU=true\nCHECK_MEM=true\nCHECK_DISK=true\nINTERVAL=0\nCUSTOM_THRESHOLD=0\n\
    \nwhile [[ $# -gt 0 ]]; do\n  case $1 in\n    -h|--help)\n      usage\n      ;;\n\
    \    -v|--verbose)\n      VERBOSE=true\n      shift\n      ;;\n    -c|--cpu-only)\n\
    \      CHECK_MEM=false\n      CHECK_DISK=false\n      shift\n      ;;\n    -m|--mem-only)\n\
    \      CHECK_CPU=false\n      CHECK_DISK=false\n      shift\n      ;;\n    -d|--disk-only)\n\
    \      CHECK_CPU=false\n      CHECK_MEM=false\n      shift\n      ;;\n    -t|--threshold)\n\
    \      CUSTOM_THRESHOLD=\"$2\"\n      shift 2\n      ;;\n    -i|--interval)\n\
    \      INTERVAL=\"$2\"\n      shift 2\n      ;;\n    -l|--log-file)\n      LOG_FILE=\"\
    $2\"\n      shift 2\n      ;;\n    *)\n      echo \"Unknown option: $1\"\n   \
    \   usage\n      ;;\n  esac\ndone\n```\n\n**Advanced Parsing Features:**\n- Short\
    \ and long options\n- Options with values (-t 90)\n- Boolean flags\n- Help documentation\n\
    - Input validation\n\nImplement the full argument parsing system.\n"
  hint: Use case statement for parsing, shift to consume arguments, provide help
  validation:
    type: command-output
    command: "cat > /tmp/test_args.sh << 'EOF'\n#!/bin/bash\nwhile [[ $# -gt 0 ]];\
      \ do\n  case $1 in\n    -h) echo \"Help requested\"; exit 0;;\n    *) shift;;\n\
      \  esac\ndone\nEOF\nbash /tmp/test_args.sh -h\n"
    matcher: contains
    expected: Help requested
- id: main-execution-loop
  title: Implement Main Execution Logic
  description: "**Main Execution Function:**\n\nTie everything together with proper\
    \ flow control:\n\n```bash\nmain() {\n  log_info \"==========================================\"\
    \n  log_info \"System Monitor Started\"\n  log_info \"==========================================\"\
    \n\n  local exit_code=0\n\n  # Run checks based on flags\n  if [ \"$CHECK_CPU\"\
    \ = true ]; then\n    check_cpu || exit_code=$?\n  fi\n\n  if [ \"$CHECK_MEM\"\
    \ = true ]; then\n    check_memory || exit_code=$?\n  fi\n\n  if [ \"$CHECK_DISK\"\
    \ = true ]; then\n    check_disk || exit_code=$?\n  fi\n\n  # Summary\n  if [\
    \ $exit_code -eq 0 ]; then\n    echo -e \"${GREEN}‚úì All checks passed${NC}\"\n\
    \    log_info \"All checks passed successfully\"\n  else\n    echo -e \"${RED}‚úó\
    \ Some checks triggered alerts${NC}\"\n    log_warning \"Checks completed with\
    \ warnings\"\n  fi\n\n  log_info \"==========================================\"\
    \n  return $exit_code\n}\n\n# Continuous monitoring loop\nif [ \"$INTERVAL\" -gt\
    \ 0 ]; then\n  log_info \"Starting continuous monitoring (interval: ${INTERVAL}s)\"\
    \n  log_info \"Press Ctrl+C to stop\"\n\n  trap 'log_info \"Monitoring stopped\
    \ by user\"; exit 0' INT TERM\n\n  while true; do\n    main\n    sleep \"$INTERVAL\"\
    \n  done\nelse\n  # Single run\n  main\n  exit $?\nfi\n```\n\n**Advanced Features:**\n\
    - Conditional execution based on flags\n- Exit code handling\n- Signal trapping\
    \ for graceful shutdown\n- Continuous monitoring mode\n- Color-coded output\n\
    - Comprehensive logging\n\nComplete the main execution logic.\n"
  hint: Use trap for signal handling, test flags before running checks, handle exit
    codes
  validation:
    type: command-output
    command: "cat > /tmp/test_main.sh << 'EOF'\n#!/bin/bash\nmain() {\n  echo \"Main\
      \ executed\"\n  return 0\n}\nmain\nEOF\nbash /tmp/test_main.sh\n"
    matcher: contains
    expected: Main executed
- id: error-handling-and-validation
  title: Add Robust Error Handling
  description: "**Error Handling Requirements:**\n\nAdd these safety checks at the\
    \ start of your script:\n\n```bash\n# Check if running as root (optional but recommended\
    \ for system monitoring)\ncheck_permissions() {\n  if [ \"$EUID\" -ne 0 ] && [\
    \ ! -w \"/var/log/monitor\" ]; then\n    log_warning \"Not running as root. Some\
    \ features may be limited.\"\n    LOG_FILE=\"$HOME/system-monitor.log\"\n    ERROR_LOG=\"\
    $HOME/system-monitor-error.log\"\n    log_info \"Using alternative log location:\
    \ $LOG_FILE\"\n  fi\n}\n\n# Validate dependencies\ncheck_dependencies() {\n  local\
    \ missing_deps=()\n\n  for cmd in awk grep df ps top; do\n    if ! command -v\
    \ \"$cmd\" &> /dev/null; then\n      missing_deps+=(\"$cmd\")\n    fi\n  done\n\
    \n  if [ ${#missing_deps[@]} -gt 0 ]; then\n    log_error \"Missing required commands:\
    \ ${missing_deps[*]}\"\n    exit 1\n  fi\n}\n\n# Create log directories\nensure_log_dir()\
    \ {\n  local log_dir=$(dirname \"$LOG_FILE\")\n  if [ ! -d \"$log_dir\" ]; then\n\
    \    mkdir -p \"$log_dir\" 2>/dev/null || {\n      log_error \"Cannot create log\
    \ directory: $log_dir\"\n      LOG_FILE=\"$HOME/system-monitor.log\"\n      ERROR_LOG=\"\
    $HOME/system-monitor-error.log\"\n    }\n  fi\n}\n\n# Input validation\nvalidate_threshold()\
    \ {\n  if [ \"$CUSTOM_THRESHOLD\" -gt 0 ]; then\n    if [ \"$CUSTOM_THRESHOLD\"\
    \ -lt 1 ] || [ \"$CUSTOM_THRESHOLD\" -gt 100 ]; then\n      log_error \"Threshold\
    \ must be between 1 and 100\"\n      exit 1\n    fi\n    ALERT_THRESHOLD_CPU=$CUSTOM_THRESHOLD\n\
    \    ALERT_THRESHOLD_MEM=$CUSTOM_THRESHOLD\n    ALERT_THRESHOLD_DISK=$CUSTOM_THRESHOLD\n\
    \  fi\n}\n\n# Run all checks before main execution\ncheck_permissions\ncheck_dependencies\n\
    ensure_log_dir\nvalidate_threshold\n```\n\n**Error Handling Best Practices:**\n\
    - Check permissions early\n- Validate all dependencies\n- Provide fallbacks for\
    \ failures\n- Validate user input\n- Create directories safely\n- Meaningful error\
    \ messages\n\nAdd comprehensive error handling to your script.\n"
  hint: Check command existence with 'command -v', validate numeric ranges, handle
    directory creation
  validation:
    type: command-output
    command: command -v awk && echo 'Command check works'
    matcher: contains
    expected: Command check works
- id: final-testing
  title: Test Complete System
  description: "**Final Integration Test:**\n\nYour complete system monitor should\
    \ now:\n\n‚úì Accept command-line arguments\n‚úì Parse options correctly\n‚úì Check\
    \ dependencies\n‚úì Handle permissions gracefully\n‚úì Monitor CPU usage\n‚úì Monitor\
    \ memory usage\n‚úì Monitor disk usage\n‚úì Log events with timestamps\n‚úì Trigger\
    \ alerts on thresholds\n‚úì Support continuous monitoring\n‚úì Handle signals gracefully\n\
    ‚úì Provide colored output\n‚úì Exit with appropriate codes\n\n**Test Commands:**\n\
    \n1. Basic run:\n   ```bash\n   chmod +x ~/scripts/sysmonitor.sh\n   ~/scripts/sysmonitor.sh\n\
    \   ```\n\n2. Show help:\n   ```bash\n   ~/scripts/sysmonitor.sh --help\n   ```\n\
    \n3. Check CPU only:\n   ```bash\n   ~/scripts/sysmonitor.sh --cpu-only\n   ```\n\
    \n4. Custom threshold:\n   ```bash\n   ~/scripts/sysmonitor.sh -t 50 --verbose\n\
    \   ```\n\n5. Verify logs created:\n   ```bash\n   ls -la ~/logs/\n   cat ~/logs/system.log\n\
    \   ```\n\n**Debugging Tips:**\n- Add set -x for debugging\n- Use set -e to exit\
    \ on errors\n- Test each function individually\n- Check log files for errors\n\
    - Verify exit codes: echo $?\n\n**This is a master-level challenge - you must\
    \ integrate all concepts!**\n"
  hint: 'Integration checklist:

    ‚òê All functions defined

    ‚òê Argument parsing works

    ‚òê Dependencies checked

    ‚òê Logs being written

    ‚òê CPU check functional

    ‚òê Memory check functional

    ‚òê Disk check functional

    ‚òê Colors work

    ‚òê Help displays

    ‚òê Exit codes correct

    '
  validation:
    type: command-output
    command: "# Create a complete working version for validation\ncat > /tmp/sysmonitor_test.sh\
      \ << 'COMPLETE_SCRIPT'\n#!/bin/bash\nLOG_FILE=\"/tmp/system.log\"\nlog_info()\
      \ { echo \"[INFO] $*\" >> \"$LOG_FILE\"; echo \"[INFO] $*\"; }\ncheck_cpu()\
      \ { log_info \"CPU check passed\"; return 0; }\ncheck_memory() { log_info \"\
      Memory check passed\"; return 0; }\ncheck_disk() { log_info \"Disk check passed\"\
      ; return 0; }\nmain() {\n  log_info \"System Monitor Started\"\n  check_cpu\
      \ && check_memory && check_disk\n  log_info \"All checks completed\"\n  return\
      \ 0\n}\nmain\nCOMPLETE_SCRIPT\nchmod +x /tmp/sysmonitor_test.sh\n/tmp/sysmonitor_test.sh\
      \ && echo \"SUCCESS\"\n"
    matcher: contains
    expected: SUCCESS
completion:
  message: 'üèÜ MASTER CHALLENGE CONQUERED! üèÜ


    You''ve built a PRODUCTION-GRADE system monitoring tool from scratch!


    **What You''ve Accomplished:**


    ‚úì Professional script structure with documentation

    ‚úì Multi-level logging system (INFO, WARNING, ERROR)

    ‚úì CPU monitoring with /proc/stat parsing

    ‚úì Memory monitoring with detailed analysis

    ‚úì Disk space monitoring with directory analysis

    ‚úì Comprehensive argument parsing (short & long options)

    ‚úì Error handling and input validation

    ‚úì Dependency checking

    ‚úì Continuous monitoring mode

    ‚úì Signal handling (Ctrl+C gracefully)

    ‚úì Color-coded output

    ‚úì Log file management

    ‚úì Exit code handling

    ‚úì Professional help documentation


    **Advanced Techniques Mastered:**


    - Complex function design

    - /proc filesystem parsing

    - awk for data processing

    - bc for floating-point math

    - Process management (ps, top)

    - Signal trapping

    - Case statement parsing

    - Array handling

    - Conditional execution

    - I/O redirection (tee, stderr)

    - File system navigation

    - String manipulation

    - Integer arithmetic

    - Command substitution

    - Exit code propagation


    **Real-World Applications:**


    This script can be used in production to:

    - Monitor server health

    - Trigger automated responses

    - Send alerts to administrators

    - Log system performance

    - Detect resource exhaustion

    - Schedule via cron for continuous monitoring


    **Skills Demonstrated:**


    You''ve proven mastery of:

    ‚òë Shell scripting fundamentals (CLR 5)

    ‚òë System administration (CLR 4)

    ‚òë Problem decomposition (CLR 6)

    ‚òë Error handling (CLR 5)

    ‚òë Documentation (CLR 6)

    ‚òë Testing and validation (CLR 6)


    You''re now ready for professional DevOps work!


    **Next Steps:**

    - Add email alerting

    - Integrate with monitoring systems (Prometheus, Grafana)

    - Add network monitoring

    - Create web dashboard

    - Package as systemd service


    CONGRATULATIONS ON COMPLETING THIS MASTER-LEVEL CHALLENGE!

    '
  xp: 1500
  unlocks:
  - linux/week13/regex-text-processing-advanced
  - linux/week14/ssh-security-expert
