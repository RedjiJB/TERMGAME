mission:
  id: "shell-scripting-advanced"
  title: "Advanced Shell Scripting: Arrays, Regex, and Process Management"
  difficulty: "advanced"
  description: |
    Master advanced bash scripting techniques including arrays, regular expressions,
    process management, and command-line argument parsing. Build production-ready
    scripts with professional features.

    Unlock expert-level scripting capabilities!
  estimated_time: "55 minutes"
  xp_reward: 600
  tags:
    - "shell-scripting"
    - "bash"
    - "arrays"
    - "regex"
    - "advanced"
    - "week11"

environment:
  runtime: "docker"
  base_image: "ubuntu:22.04"
  setup: |
    apt-get update && apt-get install -y \
      bash \
      coreutils \
      procps

steps:
  - id: "arrays"
    description: |
      **Bash Arrays**

      **Indexed arrays:**
      ```bash
      # Declaration
      arr=(apple banana cherry)
      arr[3]="date"

      # Access
      echo ${arr[0]}        # First element
      echo ${arr[@]}        # All elements
      echo ${#arr[@]}       # Length

      # Iteration
      for item in "${arr[@]}"; do
        echo "$item"
      done
      ```

      **Associative arrays (bash 4+):**
      ```bash
      declare -A map
      map[key1]="value1"
      map[key2]="value2"

      echo ${map[key1]}
      ```

      **Task:** Work with arrays.

      ```bash
      mkdir -p ~/advanced_scripting
      cd ~/advanced_scripting

      cat > arrays.sh << 'EOF'
      #!/bin/bash
      # Array demonstration

      # Indexed array
      fruits=(apple banana cherry date elderberry)

      echo "Array Demo"
      echo "=========="
      echo "All fruits: ${fruits[@]}"
      echo "Count: ${#fruits[@]}"
      echo "First: ${fruits[0]}"
      echo "Last: ${fruits[-1]}"

      # Iterate
      echo ""
      echo "Iteration:"
      for i in "${!fruits[@]}"; do
        echo "  $i: ${fruits[$i]}"
      done

      # Slice
      echo ""
      echo "Slice [1:3]: ${fruits[@]:1:3}"

      # Associative array
      declare -A scores
      scores[alice]=95
      scores[bob]=87
      scores[carol]=92

      echo ""
      echo "Scores:"
      for name in "${!scores[@]}"; do
        echo "  $name: ${scores[$name]}"
      done
      EOF

      chmod +x arrays.sh

      echo "Arrays Output" > arrays_output.txt
      echo "=============" >> arrays_output.txt
      ./arrays.sh >> arrays_output.txt

      cat arrays_output.txt
      ```
    hint: |
      Use ${arr[@]} for all elements, ${#arr[@]} for count, ${!arr[@]} for
      indices. Always quote: "${arr[@]}" to preserve spaces.
    validation:
      - type: "file-exists"
        path: "~/advanced_scripting/arrays_output.txt"

  - id: "regex-and-pattern-matching"
    description: |
      **Regular Expressions**

      **Pattern matching:**
      ```bash
      # =~ operator for regex
      if [[ $string =~ ^[0-9]+$ ]]; then
        echo "Number"
      fi

      # Glob patterns
      case $file in
        *.txt) echo "Text file" ;;
        *.jpg|*.png) echo "Image" ;;
      esac
      ```

      **String manipulation:**
      ```bash
      # Remove prefix/suffix
      ${var#prefix}    # Remove shortest prefix
      ${var##prefix}   # Remove longest prefix
      ${var%suffix}    # Remove shortest suffix
      ${var%%suffix}   # Remove longest suffix

      # Substring
      ${var:position:length}
      ```

      **Task:** Use regex and patterns.

      ```bash
      cat > validator.sh << 'EOF'
      #!/bin/bash
      # Input validator

      validate_email() {
        local email="$1"
        if [[ $email =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
          echo "✓ Valid email: $email"
          return 0
        else
          echo "✗ Invalid email: $email"
          return 1
        fi
      }

      validate_ip() {
        local ip="$1"
        if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
          echo "✓ Valid IP format: $ip"
          return 0
        else
          echo "✗ Invalid IP format: $ip"
          return 1
        fi
      }

      extract_extension() {
        local filename="$1"
        echo "File: $filename"
        echo "  Extension: ${filename##*.}"
        echo "  Name only: ${filename%.*}"
      }

      # Test
      echo "Email Validation:"
      validate_email "user@example.com"
      validate_email "invalid.email"

      echo ""
      echo "IP Validation:"
      validate_ip "192.168.1.1"
      validate_ip "999.999.999.999"

      echo ""
      echo "Filename Parsing:"
      extract_extension "document.txt"
      extract_extension "archive.tar.gz"
      EOF

      chmod +x validator.sh

      echo "Regex and Pattern Matching" > regex_output.txt
      echo "==========================" >> regex_output.txt
      ./validator.sh >> regex_output.txt

      cat regex_output.txt
      ```
    hint: |
      Use [[ ]] for regex with =~. Use ${var#pattern} to remove from start,
      ${var%pattern} to remove from end. # is shortest, ## is longest.
    validation:
      - type: "file-exists"
        path: "~/advanced_scripting/regex_output.txt"

  - id: "process-management"
    description: |
      **Process Management in Scripts**

      **Background jobs:**
      ```bash
      command &           # Run in background
      wait                # Wait for all background jobs
      wait $PID          # Wait for specific process
      ```

      **Process control:**
      ```bash
      # Check if process running
      if pgrep -x "process_name" > /dev/null; then
        echo "Running"
      fi

      # Get PID
      PID=$(pgrep -x "process_name")
      ```

      **Task:** Manage processes.

      ```bash
      cat > process_manager.sh << 'EOF'
      #!/bin/bash
      # Process management

      # Start multiple background jobs
      run_tasks() {
        echo "Starting background tasks..."

        sleep 2 &
        pid1=$!
        echo "  Task 1 started (PID: $pid1)"

        sleep 3 &
        pid2=$!
        echo "  Task 2 started (PID: $pid2)"

        sleep 1 &
        pid3=$!
        echo "  Task 3 started (PID: $pid3)"

        # Store PIDs
        pids=($pid1 $pid2 $pid3)

        echo ""
        echo "Waiting for tasks to complete..."

        # Wait for each
        for pid in "${pids[@]}"; do
          if wait $pid; then
            echo "  Task $pid completed successfully"
          else
            echo "  Task $pid failed"
          fi
        done

        echo ""
        echo "All tasks complete!"
      }

      # Monitor function
      monitor_process() {
        local name="$1"
        if pgrep -x "$name" > /dev/null; then
          echo "Process '$name' is running"
          echo "  PIDs: $(pgrep -x "$name" | tr '\n' ' ')"
        else
          echo "Process '$name' is not running"
        fi
      }

      # Main
      echo "Process Management Demo"
      echo "======================="
      echo ""

      run_tasks

      echo ""
      monitor_process "bash"
      EOF

      chmod +x process_manager.sh

      echo "Process Management Output" > process_output.txt
      echo "=========================" >> process_output.txt
      ./process_manager.sh >> process_output.txt

      cat process_output.txt
      ```
    hint: |
      $! gives PID of last background job. Use 'wait' to wait for completion.
      pgrep finds processes by name. Always save PIDs if you need to control jobs.
    validation:
      - type: "file-exists"
        path: "~/advanced_scripting/process_output.txt"

  - id: "argument-parsing"
    description: |
      **Advanced Argument Parsing**

      **Using getopts:**
      ```bash
      while getopts "f:vo:" opt; do
        case $opt in
          f) file="$OPTARG" ;;
          v) verbose=true ;;
          o) output="$OPTARG" ;;
          \?) echo "Invalid option" ;;
        esac
      done
      shift $((OPTIND-1))  # Remove processed options
      ```

      **Task:** Build complete argument parser.

      ```bash
      cat > data_processor.sh << 'EOF'
      #!/bin/bash
      # Data processor with full argument parsing

      # Defaults
      input_file=""
      output_file="output.txt"
      verbose=false
      operation="count"

      # Usage
      usage() {
        cat << USAGE
      Usage: $0 [OPTIONS] input_file

      Options:
        -i FILE    Input file (required)
        -o FILE    Output file (default: output.txt)
        -v         Verbose mode
        -a ACTION  Action: count, sort, unique (default: count)
        -h         Show this help

      Examples:
        $0 -i data.txt
        $0 -i data.txt -o result.txt -a sort
        $0 -v -i data.txt -a unique
      USAGE
        exit 1
      }

      # Parse options
      while getopts "i:o:va:h" opt; do
        case $opt in
          i) input_file="$OPTARG" ;;
          o) output_file="$OPTARG" ;;
          v) verbose=true ;;
          a) operation="$OPTARG" ;;
          h) usage ;;
          \?) usage ;;
        esac
      done

      # Validate
      if [ -z "$input_file" ]; then
        echo "Error: Input file required"
        usage
      fi

      if [ ! -f "$input_file" ]; then
        echo "Error: File not found: $input_file"
        exit 1
      fi

      # Log function
      log() {
        if [ "$verbose" = true ]; then
          echo "[LOG] $*"
        fi
      }

      # Process
      log "Input: $input_file"
      log "Output: $output_file"
      log "Operation: $operation"

      case $operation in
        count)
          wc -l "$input_file" > "$output_file"
          ;;
        sort)
          sort "$input_file" > "$output_file"
          ;;
        unique)
          sort "$input_file" | uniq > "$output_file"
          ;;
        *)
          echo "Unknown operation: $operation"
          exit 1
          ;;
      esac

      log "Processing complete"
      echo "Results saved to: $output_file"
      EOF

      chmod +x data_processor.sh

      # Create test data
      cat > sample_data.txt << 'EOF'
      apple
      banana
      apple
      cherry
      banana
      EOF

      echo "Argument Parsing Demo" > arg_parsing_output.txt
      echo "=====================" >> arg_parsing_output.txt
      ./data_processor.sh -i sample_data.txt -a unique -v >> arg_parsing_output.txt 2>&1

      cat arg_parsing_output.txt
      ```
    hint: |
      getopts processes options. Use : after letter for required argument.
      shift $((OPTIND-1)) to access remaining non-option arguments.
    validation:
      - type: "file-exists"
        path: "~/advanced_scripting/arg_parsing_output.txt"

  - id: "production-script"
    description: |
      **Production-Ready Script**

      **Task:** Build a complete monitoring script.

      ```bash
      cat > system_monitor.sh << 'EOF'
      #!/bin/bash
      # System monitoring script

      set -euo pipefail

      # Configuration
      THRESHOLD_CPU=80
      THRESHOLD_MEM=80
      THRESHOLD_DISK=80
      LOG_FILE="monitor.log"

      # Colors (if terminal)
      if [ -t 1 ]; then
        RED='\033[0;31m'
        YELLOW='\033[0;33m'
        GREEN='\033[0;32m'
        NC='\033[0m'
      else
        RED='' YELLOW='' GREEN='' NC=''
      fi

      # Logging
      log() {
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
      }

      # Check CPU
      check_cpu() {
        local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 | cut -d'.' -f1 2>/dev/null || echo "0")

        if [ "$cpu_usage" -gt "$THRESHOLD_CPU" ]; then
          echo -e "${RED}⚠ CPU: ${cpu_usage}%${NC}"
          log "WARNING: High CPU usage: ${cpu_usage}%"
        else
          echo -e "${GREEN}✓ CPU: ${cpu_usage}%${NC}"
        fi
      }

      # Check disk
      check_disk() {
        local disk_usage=$(df -h / | awk 'NR==2 {print $5}' | tr -d '%')

        if [ "$disk_usage" -gt "$THRESHOLD_DISK" ]; then
          echo -e "${RED}⚠ Disk: ${disk_usage}%${NC}"
          log "WARNING: High disk usage: ${disk_usage}%"
        else
          echo -e "${GREEN}✓ Disk: ${disk_usage}%${NC}"
        fi
      }

      # Main report
      generate_report() {
        echo "================================"
        echo "System Monitor Report"
        echo "================================"
        echo "Timestamp: $(date)"
        echo ""

        check_cpu
        check_disk

        echo ""
        echo "Top 3 processes by CPU:"
        ps aux --sort=-%cpu | head -4 | tail -3

        echo ""
        log "Monitoring check complete"
      }

      # Main
      generate_report
      EOF

      chmod +x system_monitor.sh

      echo "System Monitor Output" > monitor_output.txt
      echo "=====================" >> monitor_output.txt
      ./system_monitor.sh >> monitor_output.txt 2>&1

      cat monitor_output.txt
      ```

      **Congratulations!** You've mastered advanced shell scripting!

      **You learned:**
      - Arrays (indexed and associative)
      - Regular expressions and pattern matching
      - Process management and background jobs
      - Professional argument parsing
      - Production-ready script structure

      **Professional techniques:**
      - Use arrays for collections
      - Validate with regex
      - Manage background processes
      - Parse arguments with getopts
      - Add logging and error handling
      - Use colors for better UX

      You can now write professional, production-ready scripts!
    hint: |
      Professional scripts have: set -euo pipefail, argument parsing, logging,
      error handling, usage help, and good structure. Always validate inputs!
    validation:
      - type: "file-exists"
        path: "~/advanced_scripting/monitor_output.txt"
